namespace network;

// There are 3 types of packets sent through the network.
// - NetworkPacket: Messages from and to consensus.
//                  The payload is opaque to the network layer.
// - NetworkRequest: Requests to another peer.
//                   The network layer expects a response back in some cases.
// - NetworkResponse: Response to a request.
// These 3 types are aggregated on the root type NetworkMessage.

/// NetworkId is a uint16 value.
table NetworkId { id: uint16; }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                              Network packet                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


enum Direction: uint8 {
    Direct, Broadcast
}

table Destination {
    variant: Direction;
    /// should only be set if Direction is Direct.
    target: uint64;
}

table NetworkPacket {
    /// whether this message has to be broadcasted or is only for our consensus
    /// instance.
    destination: Destination;
    /// the network Id in which the packet has to be considered.
    networkId: uint16;
    /// the payload of the packet. First byte will be read by the code that
    /// connects the network and the consensus layers. Will be interpreted
    /// following this table:
    ///  - 0: Block
    ///  - 1: Transaction
    ///  - 2: FinalizationRecord
    ///  - 3: FinalizationMessage
    ///  - 4: CatchUpStatus
    /// These payloads are generated by the consensus layer and MUST NOT be
    /// modified by the network layer.
    payload: [uint8];
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             Network request                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

enum RequestVariant: uint8 {
    Ping = 0,
    GetPeers = 1,
    Handshake = 2,
    // 3 and 4 were used for BanNode and UnbanNode which are deprecated now.
    JoinNetwork = 5,
    LeaveNetwork = 6
}

/// A Version is utf-8 encoded and serialized. Comes from the `semver` crate.
/// This is mainly an adapter for creating vectors of Versions.
table Version { version: [uint8]; }

/// A BlockHash is a list of bytes.
/// This is mainly an adapter for creating vectors of BlockHashes.
table BlockHash { genesisBlock: [uint8]; }

table Handshake {
    /// the version of this message. Later versions are expected to append new
    /// fields at the end so messages should still be understood to some extent.
    version: uint8;
    /// the node id of the sender.
    nodeId: uint64;
    /// the port of the sender.
    port: uint16;
    /// the network ids in which the sender node participates.
    networkIds: [uint16];
    /// the version of the node that the sender is running. Deprecated and
    /// incompatible versions will be rejected on handshake.
    nodeVersion: Version;
    /// the version of the messaging protocol that the sender is
    /// running. Incompatible versions will be rejected on handshake as they are
    /// assumed to use new messsages or expect a different behavior from the
    /// other party.
    wireVersions: [uint8];
    /// the list of genesis block hash and later regenesis blocks hashes that are
    /// known by the sender's consensus layer. If running a bootstrapper node,
    /// this list will be provided by a CLI flag as there is no consensus
    /// container running. Only when the sender's list of a prefix of the
    /// receiver's list or viceversa, handshake will succeed as both nodes belong
    /// to the same network.
    genesisBlocks: [BlockHash];
    /// a zero knowledge proof provided by the sender. Currently unused.
    zk: [uint8];
}

/// An adapter for creating lists of network Ids.
table NetworkIds { ids: [uint16]; }

union RequestPayload {
      /// to be used by GetPeers variant.
      NetworkIds,
      /// to be used by Handshake variant.
      Handshake,
      /// to be used by Join/LeaveNetwork variants.
      NetworkId
}

/// A network request is an enum with different payloads:
/// - Ping: has no payload. Expects a Pong message back.
/// - GetPeers: specifies to which network ids must the peers belong.
///             Expects a PeerList message back.
/// - Handshake: the other party will send another Handshake request in response.
/// - Join/LeaveNetwork: carries a single network id.
table NetworkRequest {
    variant: RequestVariant;
    payload: RequestPayload;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             Network response                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


enum ResponseVariant: uint8 { Pong, PeerList }

enum IpVariant: uint8 { V4, V6 }

table IpAddr {
    variant: IpVariant;
    octets: [uint8];
}

enum PeerVariant: uint8 { Node, Bootstrapper }

/// A P2PPeer value contains the id, addr, port and variant of the peer. It is
/// sent by PeerList to provide new peers to the node that sent a GetPeers
/// request.
table P2PPeer {
    id: uint64;
    addr: IpAddr;
    port: uint16;
    variant: PeerVariant;
}

/// A list of peers.
table PeerList { peers: [P2PPeer]; }

union ResponsePayload { PeerList }

/// A network reponse is an enum with an optional payload:
/// - Pong: has no payload. Answers to a Ping request.
/// - PeerList: contains a list of new peers for the node that sent a GetPeers
///             request.
table NetworkResponse {
    variant: ResponseVariant;
    payload: ResponsePayload;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             Network message                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


union NetworkPayload { NetworkPacket, NetworkRequest, NetworkResponse }

/// A Network message is either a packet, a request or a response.
table NetworkMessage {
    timestamp: uint64;
    payload: NetworkPayload;
}

/// Used as a "magic number" for the protocol. It is used as a prologue for the
/// noise handshake session too. Every message can then check
/// `NetworkMessageBufferHasIdentifier` which in Rust is named
/// `network_message_buffer_has_identifier`.
file_identifier "CP2P";

root_type NetworkMessage;
