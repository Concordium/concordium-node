{-# LANGUAGE DataKinds #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

-- |Part of the implementation of the GRPC2 interface. This module constructs
--    responses to queries that are handled by the Haskell part of the code.
--
--   This module only provides foreign exports, and should not be imported from
--   other Haskell code.
module Concordium.External.GRPC2 () where

import Concordium.GRPC2
import Control.Concurrent
import qualified Data.ByteString as BS
import qualified Data.ByteString.Short as BSS
import qualified Data.ByteString.Unsafe as BS
import Data.Coerce
import qualified Data.FixedByteString as FBS
import Data.Foldable (toList)
import Data.Int
import qualified Data.ProtoLens as Proto
import qualified Data.ProtoLens.Combinators as Proto
import qualified Data.Serialize as S
import qualified Data.Vector as Vec
import Data.Word
import Foreign
import Lens.Micro.Platform
import qualified Proto.V2.Concordium.Types as Proto
import qualified Proto.V2.Concordium.Types_Fields as ProtoFields

import qualified Concordium.GlobalState.ContractStateV1 as StateV1
import Concordium.ID.Types
import qualified Concordium.Queries as Q
import Concordium.Types

import qualified Concordium.External as Ext
import qualified Concordium.Logger as Logger
import Concordium.MultiVersion (
    MVR (..),
    mvLog,
 )

import Concordium.Crypto.SHA256 (DigestSize, Hash (Hash))
import Concordium.GlobalState.Parameters (CryptographicParameters)
import Concordium.ID.Parameters (withGlobalContext)
import qualified Concordium.Types.InvokeContract as InvokeContract
import qualified Concordium.Wasm as Wasm
import Data.Text (Text)
import qualified Data.Text.Encoding as Text

-- |An opaque representation of a Rust vector. This is used by callbacks to copy
-- the message generated by a query to Rust, so it can be forwarded back to the
-- caller.
data ReceiverVec

-- |An opaque representation of Rust cryptographic parameters. This is used by callbacks to copy
-- cryptographic parameters to Rust, so it can be forwarded back to the caller.
data ReceiverCryptographicParameters

-- |A type of callback that extends the given vector with the provided data.
type CopyToVecCallback = Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()

-- |A type of callback that extends the given vector with the provided data.
type CopyCryptographicParametersCallback = Ptr ReceiverCryptographicParameters -> Ptr CryptographicParameters -> IO ()

-- |An opaque representation of a channel to which streaming responses can write
-- data. When a request is made to an endpoint with a streaming response then a
-- channel is created in Rust code. One endpoint is passed to Haskell and the
-- other end (the receiver) is kept by the request handler. Haskell code is
-- meant to spawn a background thread that streams data into the channel, using
-- the provided 'ChannelSendCallback' to write each item into the channel.
data SenderChannel

-- |The type of callbacks to enqueue the given data in the channel. The response
-- code of 0 means data was successfully enqueued, 1 means that the channel is
-- now full, so data was not enqueued. The sender should try again. Response of
-- 2 means the channel is dead. In this case the provided 'SenderChannel' is
-- dropped, and the callback must not be invoked again.
type ChannelSendCallback = Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callChannelSendCallback :: FunPtr ChannelSendCallback -> ChannelSendCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyToVecCallback :: FunPtr CopyToVecCallback -> CopyToVecCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyCryptographicParametersCallback :: FunPtr CopyCryptographicParametersCallback -> CopyCryptographicParametersCallback

-- |NB: Assumes the data is at least 32 bytes
decodeBlockHashInput :: Word8 -> Ptr Word8 -> IO Q.BlockHashInput
decodeBlockHashInput 0 _ = return Q.BHIBest
decodeBlockHashInput 1 _ = return Q.BHILastFinal
decodeBlockHashInput _ hsh = Q.BHIGiven . coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

-- | Decode an account address from a foreign ptr. Assumes 32 bytes are available.
decodeAccountAddress :: Ptr Word8 -> IO AccountAddress
decodeAccountAddress accPtr = coerce <$> FBS.create @AccountAddressSize (\p -> copyBytes p accPtr 32)

-- |NB: Assumes the data is at least 32 bytes.
decodeTransactionHashInput :: Ptr Word8 -> IO TransactionHash
decodeTransactionHashInput hsh = coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

-- | Decode an account address from a foreign ptr.
decodeAccountIdentifierInput :: Word8 -> Ptr Word8 -> IO AccountIdentifier
decodeAccountIdentifierInput 0 dta = AccAddress <$> decodeAccountAddress dta
decodeAccountIdentifierInput 1 dta = do
    bs <- BS.unsafePackCStringLen (castPtr dta, 48)
    case S.decode bs of
        Left err -> error $ "Precondition violation in FFI call: " ++ err
        Right cid -> return (CredRegID cid)
decodeAccountIdentifierInput 2 dta = AccIndex . AccountIndex <$> peek (castPtr dta)
decodeAccountIdentifierInput n _ = error $ "Unknown account identifier tag: " ++ show n

decodeModuleRefInput :: Ptr Word8 -> IO ModuleRef
decodeModuleRefInput modRef = coerce <$> FBS.create @DigestSize (\p -> copyBytes p modRef 32)

-- |NB: Assumes the data is valid utf8. The caller is expected to guarantee
-- this.
decodeText :: Ptr Word8 -> Word32 -> IO Text
decodeText ptr len = Text.decodeUtf8 <$> BS.packCStringLen (castPtr ptr, fromIntegral len)

-- |NB: Assumes the data is valid utf8. Protobuf guarantees this, and Rust/tonic
-- does actually implement the validation, so this is safe.
decodeReceiveName :: Ptr Word8 -> Word32 -> IO Wasm.ReceiveName
decodeReceiveName ptr len = Wasm.ReceiveName <$> decodeText ptr len

-- |The result type of a gRPC2 query.
data QueryResult
    = -- | An invalid argument was provided by the client.
      QRInvalidArgument
    | -- | An internal error occured.
      QRInternalError
    | -- | The query succeeded.
      QRSuccess
    | -- | The requested data could not be found.
      QRNotFound

-- |Convert a QueryResult to a result code.
queryResultCode :: QueryResult -> Int64
queryResultCode QRInvalidArgument = -2
queryResultCode QRInternalError = -1
queryResultCode QRSuccess = 0
queryResultCode QRNotFound = 1

getAccountInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
    Word8 ->
    -- |Serialized identifier. Length determined by the type.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getAccountInfoV2 cptr blockType blockHashPtr accIdType accIdBytesPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    ai <- decodeAccountIdentifierInput accIdType accIdBytesPtr
    res <- runMVR (Q.getAccountInfo bhi ai) mvr
    returnMessageWithBlock (copier outVec) outHash res

copyHashTo :: Ptr Word8 -> BlockHash -> IO ()
copyHashTo dest (BlockHash (Hash h)) = FBS.withPtrReadOnly h $ \p -> copyBytes dest p 32

getAccountListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAccountListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mAddresses) <- runMVR (Q.getAccountList bhi) mvr
    case mAddresses of
        Nothing -> return (queryResultCode QRNotFound)
        Just addresses -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) addresses
            return (queryResultCode QRSuccess)

getModuleListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getModuleListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getModuleList bhi) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getModuleSourceV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Module reference.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getModuleSourceV2 cptr blockType blockHashPtr moduleRefPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    modRef <- decodeModuleRefInput moduleRefPtr
    res <- runMVR (Q.getModuleSource bhi modRef) mvr
    returnMessageWithBlock (copier outVec) outHash res

getInstanceListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getInstanceListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mInstances) <- runMVR (Q.getInstanceList bhi) mvr
    case mInstances of
        Nothing -> return (queryResultCode QRNotFound)
        Just instances -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) instances
            return (queryResultCode QRSuccess)

getInstanceInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Smart contract instance index.
    Word64 ->
    -- |Smart contract instance subindex.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getInstanceInfoV2 cptr blockType blockHashPtr addrIndex addrSubindex outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    let caddr = ContractAddress (ContractIndex addrIndex) (ContractSubindex addrSubindex)
    res <- runMVR (Q.getInstanceInfo bhi caddr) mvr
    returnMessageWithBlock (copier outVec) outHash res

-- |An opaque representation of the place where we write the mutable state in the 'getInstanceStateV2' query.
data PersistentStateReceiver

-- |A type of callback that copies the V1 contract persistent state into the
-- provided receveir.
type PersistentStateCopier = Ptr PersistentStateReceiver -> Ptr StateV1.PersistentState -> StateV1.LoadCallback -> IO ()

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callPersistentStateCopier :: FunPtr PersistentStateCopier -> PersistentStateCopier

getInstanceStateV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Smart contract instance index.
    Word64 ->
    -- |Smart contract instance subindex.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    -- |If the instance is a V0 instance its instance state is written to this vector.
    -- Otherwise this is unused.
    Ptr ReceiverVec ->
    -- |Callback to output data in case it is a V0 instance.
    FunPtr CopyToVecCallback ->
    -- |If the instance is a V1 instance its instance state and callbacks are written to this vector.
    Ptr PersistentStateReceiver ->
    -- |Callback to copy the persistent state into provided receiver. The
    -- ownership of the state is retained by Haskell, and a copy is given to
    -- Rust.
    FunPtr PersistentStateCopier ->
    IO Int64
getInstanceStateV2 cptr blockType blockHashPtr addrIndex addrSubindex outHash outVec vecCopierCbk outMS msCopierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    bhi <- decodeBlockHashInput blockType blockHashPtr
    let caddr = ContractAddress (ContractIndex addrIndex) (ContractSubindex addrSubindex)
    (bh, res) <- runMVR (Q.getInstanceState bhi caddr) mvr
    case res of
        Nothing -> return (queryResultCode QRNotFound)
        Just iState -> do
            copyHashTo outHash bh
            case iState of
                Left v0State -> do
                    let copier = callCopyToVecCallback vecCopierCbk
                    BS.unsafeUseAsCStringLen (Wasm.contractState v0State) (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
                    return (queryResultCode QRSuccess)
                Right (ps, sContext) -> do
                    let copier = callPersistentStateCopier msCopierCbk
                    StateV1.withPersistentState ps $ \psPtr -> do
                        copier outMS psPtr sContext
                    return (queryResultCode QRSuccess)

getNextAccountSequenceNumberV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Serialized account address. Length is 32 bytes.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
    IO Int64
getNextAccountSequenceNumberV2 cptr accPtr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    accountAddress <- decodeAccountAddress accPtr
    res <- runMVR (Q.getNextAccountNonce accountAddress) mvr
    returnMessage (copier outVec) (Just res)

getConsensusInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr ReceiverVec ->
    FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
    IO Int64
getConsensusInfoV2 cptr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    consensusInfo <- runMVR Q.getConsensusStatus mvr
    returnMessage (copier outVec) (Just consensusInfo)

getCryptographicParametersV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverCryptographicParameters ->
    FunPtr CopyCryptographicParametersCallback ->
    IO Int64
getCryptographicParametersV2 cptr blockType blockHashPtr outHash outPtr copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyCryptographicParametersCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeCryptographicParameters) <- runMVR (Q.getCryptographicParameters bhi) mvr
    copyHashTo outHash bh
    case maybeCryptographicParameters of
        Nothing -> return $ queryResultCode QRNotFound
        Just cryptographicParameters -> do
            withGlobalContext cryptographicParameters (copier outPtr)
            return $ queryResultCode QRSuccess

getAncestorsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Amount of ancestors (depth).
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAncestorsV2 cptr channel blockType blockHashPtr depth outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getAncestors bhi (BlockHeight depth)) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getBlockItemStatusV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Transaction hash.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockItemStatusV2 cptr trxHashPtr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    trxHash <- decodeTransactionHashInput trxHashPtr
    res <- runMVR (Q.getTransactionStatus trxHash) mvr
    case res of
        Nothing -> do
            return $ queryResultCode QRNotFound
        Just ts -> case toProto ts of
            Left e -> do
                mvLog mvr Logger.External Logger.LLError $ "Internal conversion error occured for transaction '" ++ show trxHash ++ "': " ++ show e
                return $ queryResultCode QRInternalError
            Right t -> do
                let encoded = Proto.encodeMessage t
                BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
                return $ queryResultCode QRSuccess

invokeInstanceV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- | Block ID type.
    Word8 ->
    -- | Block ID pointer.
    Ptr Word8 ->
    -- | Contract index.
    Word64 ->
    -- | Contract subindex.
    Word64 ->
    -- | Invoker address tag.
    Word8 ->
    -- | Invoker account address pointer.
    Ptr Word8 ->
    -- | Invoker contract index.
    Word64 ->
    -- | Invoker contract subindex.
    Word64 ->
    -- | Amount.
    Word64 ->
    -- | ReceiveName pointer.
    Ptr Word8 ->
    -- | ReceiveName length.
    Word32 ->
    -- | Parameter pointer.
    Ptr Word8 ->
    -- | Parameter length.
    Word32 ->
    -- | Energy
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    FunPtr CopyToVecCallback ->
    IO Int64
invokeInstanceV2 cptr blockIdType blockIdPtr contractIndex contractSubindex invokerAddressType invokerAccountAddressPtr invokerContractIndex invokerContractSubindex amount receiveNamePtr receiveNameLen parameterPtr parameterLen energy outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    block <- decodeBlockHashInput blockIdType blockIdPtr
    maybeInvoker <- case invokerAddressType of
        0 -> return $ Nothing
        1 -> Just . AddressAccount <$> decodeAccountAddress invokerAccountAddressPtr
        _ -> return $ Just $ AddressContract $ ContractAddress (ContractIndex invokerContractIndex) (ContractSubindex invokerContractSubindex)
    method <- decodeReceiveName receiveNamePtr receiveNameLen
    parameter <- Wasm.Parameter . BSS.toShort <$> BS.packCStringLen (castPtr parameterPtr, fromIntegral parameterLen)
    let context =
            InvokeContract.ContractContext
                { ccInvoker = maybeInvoker,
                  ccContract = ContractAddress (ContractIndex contractIndex) (ContractSubindex contractSubindex),
                  ccAmount = Amount amount,
                  ccMethod = method,
                  ccParameter = parameter,
                  ccEnergy = Energy energy
                }
    (bh, result) <- runMVR (Q.invokeContract block context) mvr
    copyHashTo outHash bh
    case toProto <$> result of
        Nothing -> return $ queryResultCode QRNotFound
        Just (Left _) -> return $ queryResultCode QRInternalError
        Just (Right proto) -> do
            let encoded = Proto.encodeMessage proto
            BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
            return $ queryResultCode QRSuccess

getBlockInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    res <- runMVR (Q.getBlockInfo bhi) mvr
    returnMessageWithBlock (copier outVec) outHash res

getBakerListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getBakerListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mBakers) <- runMVR (Q.getRegisteredBakers bhi) mvr
    case mBakers of
        Nothing -> return (queryResultCode QRNotFound)
        Just instances -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) instances
            return (queryResultCode QRSuccess)

getPoolInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Baker id of the pool owner.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getPoolInfoV2 cptr blockType blockHashPtr bakerId outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, status) <- runMVR (Q.getPoolStatus bhi (Just $ fromIntegral bakerId)) mvr
    copyHashTo outHash bh
    case toProto <$> status of
        Just (Left proto) -> do
            let encoded = Proto.encodeMessage proto
            BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
            return $ queryResultCode QRSuccess
        _ -> return $ queryResultCode QRNotFound

getPassiveDelegationInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getPassiveDelegationInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, status) <- runMVR (Q.getPoolStatus bhi Nothing) mvr
    copyHashTo outHash bh
    case toProto <$> status of
        Just (Right proto) -> do
            let encoded = Proto.encodeMessage proto
            BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
            return $ queryResultCode QRSuccess
        _ -> return $ queryResultCode QRNotFound

getBlocksAtHeightV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- | Block height, is absolute if the genesis_index is 0, otherwise relative.
    Word64 ->
    -- | Genesis index to start from. Set to 0 to use absolute height.
    Word32 ->
    -- | Whether to return results only from the specified genesis index (1),
    -- or allow results from more recent genesis indices as well (0). Out pointer
    -- for writing the block hash that was used.
    Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlocksAtHeightV2 cptr height genIndex restrict outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    blocks <- runMVR (Q.getBlocksAtHeight (BlockHeight height) (GenesisIndex genIndex) (restrict /= 0)) mvr
    let proto :: Proto.BlocksAtHeightResponse = Proto.make $ ProtoFields.blocks .= fmap toProto blocks
    let encoded = Proto.encodeMessage proto
    BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
    return $ queryResultCode QRSuccess

getTokenomicsInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getTokenomicsInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    result <- runMVR (Q.getRewardStatus bhi) mvr
    returnMessageWithBlock (copier outVec) outHash result

getPoolDelegatorsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Baker id.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getPoolDelegatorsV2 cptr channel blockType blockHashPtr bakerId outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, eitherDelegators) <- runMVR (Q.getDelegators bhi (Just $ fromIntegral bakerId)) mvr
    case eitherDelegators of
        Left Q.GDEUnsupportedProtocolVersion -> return $ queryResultCode QRInvalidArgument
        Left Q.GDEPoolNotFound -> return $ queryResultCode QRNotFound
        Left Q.GDEBlockNotFound -> return $ queryResultCode QRNotFound
        Right delegators -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) delegators
            return (queryResultCode QRSuccess)

getPoolDelegatorsRewardPeriodV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Baker id.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getPoolDelegatorsRewardPeriodV2 cptr channel blockType blockHashPtr bakerId outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, eitherDelegators) <- runMVR (Q.getDelegatorsRewardPeriod bhi (Just $ fromIntegral bakerId)) mvr
    case eitherDelegators of
        Left Q.GDEUnsupportedProtocolVersion -> return $ queryResultCode QRInvalidArgument
        Left Q.GDEPoolNotFound -> return $ queryResultCode QRNotFound
        Left Q.GDEBlockNotFound -> return $ queryResultCode QRNotFound
        Right delegators -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) delegators
            return (queryResultCode QRSuccess)

getPassiveDelegatorsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getPassiveDelegatorsV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, eitherDelegators) <- runMVR (Q.getDelegators bhi Nothing) mvr
    case eitherDelegators of
        Left Q.GDEUnsupportedProtocolVersion -> return $ queryResultCode QRInvalidArgument
        Left Q.GDEPoolNotFound -> return $ queryResultCode QRNotFound
        Left Q.GDEBlockNotFound -> return $ queryResultCode QRNotFound
        Right delegators -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) delegators
            return (queryResultCode QRSuccess)

getPassiveDelegatorsRewardPeriodV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getPassiveDelegatorsRewardPeriodV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, eitherDelegators) <- runMVR (Q.getDelegatorsRewardPeriod bhi Nothing) mvr
    case eitherDelegators of
        Left Q.GDEUnsupportedProtocolVersion -> return $ queryResultCode QRInvalidArgument
        Left Q.GDEPoolNotFound -> return $ queryResultCode QRNotFound
        Left Q.GDEBlockNotFound -> return $ queryResultCode QRNotFound
        Right delegators -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) delegators
            return (queryResultCode QRSuccess)

getBranchesV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBranchesV2 cptr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    result <- runMVR Q.getBranches mvr
    returnMessage (copier outVec) $ Just result

getElectionInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getElectionInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeInfo) <- runMVR (Q.getBlockBirkParameters bhi) mvr
    copyHashTo outHash bh
    case maybeInfo of
        Nothing -> return $ queryResultCode QRNotFound
        Just info -> case toProto info of
            Nothing -> return $ queryResultCode QRInternalError
            Just proto -> do
                let encoded = Proto.encodeMessage proto
                BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
                return $ queryResultCode QRSuccess

getIdentityProvidersV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getIdentityProvidersV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeIdentityProviders) <- runMVR (Q.getAllIdentityProviders bhi) mvr
    copyHashTo outHash bh
    case maybeIdentityProviders of
        Nothing -> return (queryResultCode QRNotFound)
        Just ipInfos -> do
            _ <- enqueueMessages (sender channel) ipInfos
            return (queryResultCode QRSuccess)

getAnonymityRevokersV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getAnonymityRevokersV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeAnonymityRevokers) <- runMVR (Q.getAllAnonymityRevokers bhi) mvr
    copyHashTo outHash bh
    case maybeAnonymityRevokers of
        Nothing -> return (queryResultCode QRNotFound)
        Just arInfos -> do
            _ <- enqueueMessages (sender channel) arInfos
            return (queryResultCode QRSuccess)

getAccountNonFinalizedTransactionsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Serialized account address. Length is 32 bytes.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getAccountNonFinalizedTransactionsV2 cptr channel accPtr cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    accountAddress <- decodeAccountAddress accPtr
    res <- runMVR (Q.getAccountNonFinalizedTransactions accountAddress) mvr
    _ <- enqueueMessages (sender channel) res
    return (queryResultCode QRSuccess)

-- |Get the block items for a block.
getBlockItemsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type
    Word8 ->
    -- |Block hash ptr.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getBlockItemsV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mBis) <- runMVR (Q.getBlockItems bhi) mvr
    case mBis of
        Nothing -> return (queryResultCode QRNotFound)
        Just items -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) items
            return (queryResultCode QRSuccess)

getBlockTransactionEventsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getBlockTransactionEventsV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeEvents) <- runMVR (Q.getBlockTransactionSummaries bhi) mvr
    copyHashTo outHash bh
    case maybeEvents of
        Nothing -> return (queryResultCode QRNotFound)
        Just events -> case traverse toProto events of
            Left e -> do
                mvLog mvr Logger.External Logger.LLError $ "Internal conversion error occured for block '" ++ show bh ++ "': " ++ show e
                return $ queryResultCode QRInternalError
            Right proto -> do
                _ <- enqueueProtoMessages (sender channel) $ Vec.toList proto
                return (queryResultCode QRSuccess)

getBlockSpecialEventsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getBlockSpecialEventsV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeEvents) <- runMVR (Q.getBlockSpecialEvents bhi) mvr
    copyHashTo outHash bh
    case maybeEvents of
        Nothing -> return (queryResultCode QRNotFound)
        Just events -> do
            _ <- enqueueMessages (sender channel) $ toList events
            return (queryResultCode QRSuccess)

getBlockPendingUpdatesV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getBlockPendingUpdatesV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeUpdates) <- runMVR (Q.getBlockPendingUpdates bhi) mvr
    copyHashTo outHash bh
    case maybeUpdates of
        Nothing -> return (queryResultCode QRNotFound)
        Just pendingUpdates -> do
            _ <- enqueueMessages (sender channel) pendingUpdates
            return (queryResultCode QRSuccess)

getNextUpdateSequenceNumbersV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getNextUpdateSequenceNumbersV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    result <- runMVR (Q.getNextUpdateSequenceNumbers bhi) mvr
    returnMessageWithBlock (copier outVec) outHash result

getBlockChainParametersV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockChainParametersV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    res <- runMVR (Q.getBlockChainParameters bhi) mvr
    returnMessageWithBlock (copier outVec) outHash res

getBlockFinalizationSummaryV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockFinalizationSummaryV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    res <- runMVR (Q.getBlockFinalizationSummary bhi) mvr
    returnMessageWithBlock (copier outVec) outHash res

-- |Get the slot time of the last finalized block.
getLastFinalizedBlockSlotTimeV2 ::
    StablePtr Ext.ConsensusRunner ->
    IO Timestamp
getLastFinalizedBlockSlotTimeV2 cptr = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    runMVR Q.getLastFinalizedSlotTime mvr

-- |Write the hash to the provided pointer, and if the message is given encode and
-- write it using the provided callback.
returnMessageWithBlock ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- |Out pointer where the hash is written.
    Ptr Word8 ->
    -- |The hash of the block to which the message belongs, and potentially a
    -- message.
    (BlockHash, Maybe a) ->
    IO Int64
returnMessageWithBlock copier outHash (bh, out) = do
    copyHashTo outHash bh
    returnMessage copier out

-- |If the message is given encode and write it using the provided callback.
returnMessage ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- | The potential message.
    Maybe a ->
    IO Int64
returnMessage copier res = case res of
    Nothing -> return $ queryResultCode QRNotFound
    Just v -> do
        let encoded = Proto.encodeMessage (toProto v)
        BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier (castPtr ptr) (fromIntegral len))
        return $ queryResultCode QRSuccess

enqueueMessages :: (Proto.Message (Output a), ToProto a) => (Ptr Word8 -> Int64 -> IO Int32) -> [a] -> IO ThreadId
enqueueMessages callback = enqueueProtoMessages callback . fmap toProto

-- |Spawn a new thread that will invoke the provided callback on the list of
-- encoded messages. If the callback response indicates that the channel to
-- which the callback is enqueueing is full, the thread will wait. The wait time
-- follows exponential backoff strategy to a maximum of 10 seconds.
enqueueProtoMessages :: (Proto.Message a) => (Ptr Word8 -> Int64 -> IO Int32) -> [a] -> IO ThreadId
enqueueProtoMessages callback = forkIO . go 0 . map Proto.encodeMessage
  where
    go _ [] = () <$ callback nullPtr maxBound -- close the sender channel.
    go n msgs@(msg : msgs') =
        BS.unsafeUseAsCStringLen msg $ \(headPtr, len) -> do
            res <- callback (castPtr headPtr) (fromIntegral len)
            if res == 0
                then go 0 msgs' -- reset wait time to 10ms.
                else
                    if res == -1
                        then do
                            let delay = (2 ^ n) * 10_000
                            threadDelay delay
                            go (min (n + 1) (10 :: Int)) msgs -- maximum delay is 10 seconds
                        else return () -- the sender channel is now dropped, so we stop.

-- * Foreign exports

foreign export ccall
    getAccountInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
        Word8 ->
        -- |Serialized identifier. Length determined by the type.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getAccountListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleSourceV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Module reference.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getInstanceListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getAncestorsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Amount of ancestors (depth).
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getInstanceInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Smart contract address index.
        Word64 ->
        -- |Smart contract address subindex.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getInstanceStateV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Smart contract instance index.
        Word64 ->
        -- |Smart contract instance subindex.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        -- |If the instance is a V0 instance its instance state is written to this vector.
        -- Otherwise this is unused.
        Ptr ReceiverVec ->
        -- |Callback to output data in case it is a V0 instance.
        FunPtr CopyToVecCallback ->
        -- |If the instance is a V1 instance its instance state and callbacks are written to this vector.
        Ptr PersistentStateReceiver ->
        -- |Callback to copy the persistent state into provided receiver. The
        -- ownership of the state is retained by Haskell, and a copy is given to
        -- Rust.
        FunPtr PersistentStateCopier ->
        IO Int64

foreign export ccall
    getNextAccountSequenceNumberV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Serialized account address. Length must be 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getBlockItemStatusV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |TransactionHash. Length must be 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getConsensusInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    invokeInstanceV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- | Block ID type.
        Word8 ->
        -- | Block ID pointer.
        Ptr Word8 ->
        -- | Contract index.
        Word64 ->
        -- | Contract subindex.
        Word64 ->
        -- | Invoker address tag.
        Word8 ->
        -- | Invoker account address pointer.
        Ptr Word8 ->
        -- | Invoker contract index.
        Word64 ->
        -- | Invoker contract subindex.
        Word64 ->
        -- | Amount.
        Word64 ->
        -- | ReceiveName pointer.
        Ptr Word8 ->
        -- | ReceiveName length.
        Word32 ->
        -- | Parameter pointer.
        Ptr Word8 ->
        -- | Parameter length.
        Word32 ->
        -- | Energy
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getCryptographicParametersV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverCryptographicParameters ->
        FunPtr CopyCryptographicParametersCallback ->
        IO Int64

foreign export ccall
    getBlockInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getBakerListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getPoolInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- | Baker id of the pool owner.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getPassiveDelegationInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getBlocksAtHeightV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- | Block height, is absolute if the genesis_index is 0, otherwise relative.
        Word64 ->
        -- | Genesis index to start from. Set to 0 to use absolute height.
        Word32 ->
        -- | Whether to return results only from the specified genesis index (1),
        -- or allow results from more recent genesis indices as well (0). Out pointer
        -- for writing the block hash that was used.
        Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getTokenomicsInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getPoolDelegatorsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Baker id.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getPoolDelegatorsRewardPeriodV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Baker id.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getPassiveDelegatorsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getPassiveDelegatorsRewardPeriodV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getBranchesV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getElectionInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getIdentityProvidersV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getAnonymityRevokersV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getAccountNonFinalizedTransactionsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Serialized account address. Length is 32 bytes.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getBlockItemsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getBlockTransactionEventsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getBlockSpecialEventsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getBlockPendingUpdatesV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getNextUpdateSequenceNumbersV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getBlockChainParametersV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        -- |Callback to output data.
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getBlockFinalizationSummaryV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        -- |Callback to output data.
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getLastFinalizedBlockSlotTimeV2 ::
        StablePtr Ext.ConsensusRunner ->
        IO Timestamp
