{-# LANGUAGE DataKinds #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

{- |Part of the implementation of the GRPC2 interface. This module constructs
    responses to queries that are handled by the Haskell part of the code.

   This module only provides foreign exports, and should not be imported from
   other Haskell code.
-}
module Concordium.GRPC2 () where

import Control.Concurrent
import qualified Data.ByteString as BS
import qualified Data.ByteString.Unsafe as BS
import qualified Data.ByteString.Short as BSS
import Data.Coerce
import qualified Data.FixedByteString as FBS
import Data.Int
import qualified Data.Map.Strict as Map
import qualified Data.ProtoLens as Proto
import qualified Data.ProtoLens.Combinators as Proto
import qualified Data.ProtoLens.Field
import qualified Data.Ratio as Ratio
import qualified Data.Serialize as S
import qualified Data.Set as Set
import qualified Data.Vector as Vec
import Data.Word
import Foreign
import Lens.Micro.Platform
import qualified Proto.Concordium.Types as Proto
import qualified Proto.Concordium.Types_Fields as ProtoFields

import Concordium.Crypto.EncryptedTransfers
import Concordium.ID.Types
import Concordium.Types
import Concordium.Types.Accounts
import qualified Concordium.Types.Queries as QueryTypes

import qualified Concordium.External as Ext -- TODO: This is not an ideal configuration.
import Concordium.MultiVersion (
    MVR (..),
    mvLog,
 )
import qualified Concordium.Logger as Logger
import qualified Concordium.Queries as Q

import Concordium.ID.Parameters (withGlobalContext)
import Concordium.Common.Time
import Concordium.Common.Version
import Concordium.Crypto.SHA256 (DigestSize, Hash (Hash))
import Concordium.Crypto.SignatureScheme (VerifyKey (..))
import Concordium.Types.Accounts.Releases
import Concordium.Types.Execution
import qualified Concordium.Wasm as Wasm
import Data.Text (Text)
import qualified Data.Text.Encoding as Text
import Data.Time (UTCTime)
import qualified Concordium.Types.Updates as Updates
import qualified Concordium.Types.Parameters as Parameters
import qualified Concordium.ID.AnonymityRevoker as ArInfo
import qualified Concordium.ID.IdentityProvider as IpInfo
import Concordium.Types.Block (AbsoluteBlockHeight(..))
import qualified Concordium.Types.InvokeContract as InvokeContract
import Concordium.GlobalState.Parameters (CryptographicParameters)


{- |An opaque representation of a Rust vector. This is used by callbacks to copy
 the message generated by a query to Rust, so it can be forwarded back to the
 caller.
-}
data ReceiverVec

{- |An opaque representation of Rust cryptographic parameters. This is used by callbacks to copy
 cryptographic parameters to Rust, so it can be forwarded back to the caller.
-}
data ReceiverCryptographicParameters

-- |A type of callback that extends the given vector with the provided data.
type CopyToVecCallback = Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()

-- |A type of callback that extends the given vector with the provided data.
type CopyCryptographicParametersCallback = Ptr ReceiverCryptographicParameters -> Ptr CryptographicParameters -> IO ()

{- |An opaque representation of a channel to which streaming responses can write
 data. When a request is made to an endpoint with a streaming response then a
 channel is created in Rust code. One endpoint is passed to Haskell and the
 other end (the receiver) is kept by the request handler. Haskell code is
 meant to spawn a background thread that streams data into the channel, using
 the provided 'ChannelSendCallback' to write each item into the channel.
-}
data SenderChannel

{- |The type of callbacks to enqueue the given data in the channel. The response
 code of 0 means data was successfully enqueued, 1 means that the channel is
 now full, so data was not enqueued. The sender should try again. Response of
 2 means the channel is dead. In this case the provided 'SenderChannel' is
 dropped, and the callback must not be invoked again.
-}
type ChannelSendCallback = Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callChannelSendCallback :: FunPtr ChannelSendCallback -> ChannelSendCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyToVecCallback :: FunPtr CopyToVecCallback -> CopyToVecCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyCryptographicParametersCallback :: FunPtr CopyCryptographicParametersCallback -> CopyCryptographicParametersCallback

-- |A helper function that can be used to construct a value of a protobuf
-- "wrapper" type by serializing the provided value @a@ using its serialize
-- instance.
--
-- More concretely, the wrapper type should be of the form
--
-- > message Wrapper {
-- >    bytes value = 1
-- > }
--
-- where the name @Wrapper@ can be arbitrary, but the @value@ field must exist,
-- and it must have type @bytes@.
mkSerialize ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        BS.ByteString
    , S.Serialize a
    ) =>
    a ->
    b
mkSerialize ek = Proto.make (ProtoFields.value .= S.encode ek)

-- |Like 'mkSerialize' above, but used to set a wrapper type whose @value@ field
-- has type @uint64@. The supplied value must be coercible to a 'Word64'.
-- Coercible here means that the value is a newtype wrapper (possibly repeated)
-- of a Word64.
mkWord64 ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word64
    , Coercible a Word64
    ) =>
    a ->
    b
mkWord64 a = Proto.make (ProtoFields.value .= coerce a)

-- |Like 'mkWord64', but for 32-bit integers instead of 64.
mkWord32 ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word32
    , Coercible a Word32
    ) =>
    a ->
    b
mkWord32 a = Proto.make (ProtoFields.value .= coerce a)

-- |Like 'mkWord32', but the supplied value must be coercible to
-- 'Word8'.
mkWord8 ::
    forall a b.
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word32
    , Coercible a Word8
    ) =>
    a ->
    b
mkWord8 a = Proto.make (ProtoFields.value .= (fromIntegral (coerce a :: Word8) :: Word32))

-- |A helper class analogous to something like Aeson's ToJSON.
-- It exists to make it more manageable to convert the internal Haskell types to
-- their Protobuf equivalents.
class ToProto a where
    -- |The corresponding Proto type.
    type Output a
    -- |A conversion function from the type to its protobuf equivalent.
    toProto :: a -> Output a

instance ToProto Amount where
    type Output Amount = Proto.Amount
    toProto = mkWord64

instance ToProto BlockHash where
    type Output BlockHash = Proto.BlockHash
    toProto = mkSerialize

instance ToProto Hash where
    type Output Hash = Proto.Sha256Hash
    toProto = mkSerialize

instance ToProto TransactionHashV0 where
    type Output TransactionHashV0 = Proto.TransactionHash
    toProto = mkSerialize

instance ToProto ModuleRef where
    type Output ModuleRef = Proto.ModuleRef
    toProto = mkSerialize

instance ToProto Wasm.WasmModule where
    type Output Wasm.WasmModule = Proto.VersionedModuleSource
    toProto (Wasm.WasmModuleV0 modul) = Proto.make (ProtoFields.v0 .=
       Proto.make (ProtoFields.value .= Wasm.moduleSource (Wasm.wmvSource modul)))
    toProto (Wasm.WasmModuleV1 modul) = Proto.make (ProtoFields.v1 .=
       Proto.make ( ProtoFields.value .= Wasm.moduleSource (Wasm.wmvSource modul)))

instance ToProto Wasm.InstanceInfo where
    type Output Wasm.InstanceInfo = Proto.InstanceInfo
    toProto Wasm.InstanceInfoV0{..} = Proto.make ( ProtoFields.v0 .= Proto.make ( do
      ProtoFields.owner .= mkSerialize iiOwner
      ProtoFields.amount .= mkWord64 iiAmount
      ProtoFields.methods .= (toProto <$> Set.toList iiMethods)
      ProtoFields.name .= toProto iiName
      ProtoFields.sourceModule .= toProto iiSourceModule
      ProtoFields.model .= toProto iiModel))
    toProto Wasm.InstanceInfoV1{..} = Proto.make ( ProtoFields.v1 .= Proto.make ( do
      ProtoFields.owner .= mkSerialize iiOwner
      ProtoFields.amount .= mkWord64 iiAmount
      ProtoFields.methods .= (toProto <$> Set.toList iiMethods)
      ProtoFields.name .= toProto iiName
      ProtoFields.sourceModule .= toProto iiSourceModule))

instance ToProto Wasm.ReceiveName where
  type Output Wasm.ReceiveName = Proto.ReceiveName
  toProto name = Proto.make $ ProtoFields.value .= Wasm.receiveName name

instance ToProto Wasm.InitName where
  type Output Wasm.InitName = Proto.InitName
  toProto name = Proto.make $ ProtoFields.value .= Wasm.initName name

instance ToProto Wasm.ContractState where
  type Output Wasm.ContractState = Proto.ContractStateV0
  toProto Wasm.ContractState{..} = Proto.make $ ProtoFields.value .= contractState

instance ToProto ContractAddress where
  type Output ContractAddress = Proto.ContractAddress
  toProto ContractAddress{..} = Proto.make $ do
    ProtoFields.index .= _contractIndex contractIndex
    ProtoFields.subindex .= _contractSubindex contractSubindex

instance ToProto BlockHeight where
    type Output BlockHeight = Proto.BlockHeight
    toProto = mkWord64

instance ToProto AbsoluteBlockHeight where
    type Output AbsoluteBlockHeight = Proto.AbsoluteBlockHeight
    toProto = mkWord64

instance ToProto AccountAddress where
    type Output AccountAddress = Proto.AccountAddress
    toProto = mkSerialize

instance ToProto Nonce where
    type Output Nonce = Proto.SequenceNumber
    toProto = mkWord64

instance ToProto UTCTime where
    type Output UTCTime = Proto.Timestamp
    toProto time = mkWord64 $ utcTimeToTimestamp time

instance ToProto Duration where
    type Output Duration = Proto.Duration
    toProto = mkWord64

instance ToProto GenesisIndex where
    type Output GenesisIndex = Proto.GenesisIndex
    toProto = mkWord32

instance ToProto ProtocolVersion where
    type Output ProtocolVersion = Proto.ProtocolVersion
    toProto P1 = Proto.PROTOCOL_VERSION_1
    toProto P2 = Proto.PROTOCOL_VERSION_2
    toProto P3 = Proto.PROTOCOL_VERSION_3
    toProto P4 = Proto.PROTOCOL_VERSION_4

instance ToProto QueryTypes.NextAccountNonce where
    type Output QueryTypes.NextAccountNonce = Proto.NextAccountSequenceNumber
    toProto QueryTypes.NextAccountNonce{..} = Proto.make $ do
      ProtoFields.sequenceNumber .= toProto nanNonce
      ProtoFields.allFinal .= nanAllFinal

instance ToProto QueryTypes.ConsensusStatus where
    type Output QueryTypes.ConsensusStatus = Proto.ConsensusInfo
    toProto QueryTypes.ConsensusStatus{..} = Proto.make $ do
      ProtoFields.bestBlock .= toProto csBestBlock
      ProtoFields.genesisBlock .= toProto csGenesisBlock
      ProtoFields.genesisTime .= toProto csGenesisTime
      ProtoFields.slotDuration .= toProto csSlotDuration
      ProtoFields.epochDuration .= toProto csEpochDuration
      ProtoFields.lastFinalizedBlock .= toProto csLastFinalizedBlock
      ProtoFields.bestBlockHeight .= toProto csBestBlockHeight
      ProtoFields.lastFinalizedBlockHeight .= toProto csLastFinalizedBlockHeight
      ProtoFields.blocksReceivedCount .= fromIntegral csBlocksReceivedCount
      ProtoFields.maybe'blockLastReceivedTime .= fmap toProto csBlockLastReceivedTime
      ProtoFields.blockReceiveLatencyEma .= csBlockReceiveLatencyEMA
      ProtoFields.blockReceiveLatencyEmsd .= csBlockReceiveLatencyEMSD
      ProtoFields.maybe'blockReceivePeriodEma .= csBlockReceivePeriodEMA
      ProtoFields.maybe'blockReceivePeriodEmsd .= csBlockReceivePeriodEMSD
      ProtoFields.blocksVerifiedCount .= fromIntegral csBlocksVerifiedCount
      ProtoFields.maybe'blockLastArrivedTime .= fmap toProto csBlockLastArrivedTime
      ProtoFields.blockArriveLatencyEma .= csBlockArriveLatencyEMA
      ProtoFields.blockArriveLatencyEmsd .= csBlockArriveLatencyEMSD
      ProtoFields.maybe'blockArrivePeriodEma .= csBlockArrivePeriodEMA
      ProtoFields.maybe'blockArrivePeriodEmsd .= csBlockArrivePeriodEMSD
      ProtoFields.transactionsPerBlockEma .= csTransactionsPerBlockEMA
      ProtoFields.transactionsPerBlockEmsd .= csTransactionsPerBlockEMSD
      ProtoFields.finalizationCount .= fromIntegral csFinalizationCount
      ProtoFields.maybe'lastFinalizedTime .= fmap toProto csLastFinalizedTime
      ProtoFields.maybe'finalizationPeriodEma .= csFinalizationPeriodEMA
      ProtoFields.maybe'finalizationPeriodEmsd .= csFinalizationPeriodEMSD
      ProtoFields.protocolVersion .= toProto csProtocolVersion
      ProtoFields.genesisIndex .= toProto csGenesisIndex
      ProtoFields.currentEraGenesisBlock .= toProto csCurrentEraGenesisBlock
      ProtoFields.currentEraGenesisTime .= toProto csCurrentEraGenesisTime

instance ToProto AccountThreshold where
    type Output AccountThreshold = Proto.AccountThreshold
    toProto = mkWord8

instance ToProto SignatureThreshold where
    type Output SignatureThreshold = Proto.SignatureThreshold
    toProto = mkWord8

instance ToProto Threshold where
    type Output Threshold = Proto.ArThreshold
    toProto = mkWord8

instance ToProto AccountIndex where
    type Output AccountIndex = Proto.AccountIndex
    toProto = mkWord64

instance ToProto BakerId where
    type Output BakerId = Proto.BakerId
    toProto = mkWord64

instance ToProto DelegatorId where
    type Output DelegatorId = Proto.DelegatorId
    toProto v = Proto.make $ ProtoFields.id .= toProto (delegatorAccountIndex v)

instance ToProto EncryptedAmount where
    type Output EncryptedAmount = Proto.EncryptedAmount
    toProto = mkSerialize

instance ToProto AccountEncryptedAmount where
    type Output AccountEncryptedAmount = Proto.EncryptedBalance
    toProto encBal =
        case _aggregatedAmount encBal of
            Nothing -> Proto.make mkEncryptedBalance
            Just (aggAmount, numAgg) -> Proto.make $ do
                mkEncryptedBalance
                ProtoFields.aggregatedAmount .= toProto aggAmount
                ProtoFields.numAggregated .= numAgg
      where
        mkEncryptedBalance = do
            ProtoFields.selfAmount .= toProto (_selfAmount encBal)
            ProtoFields.startIndex .= coerce (_startIndex encBal)

instance ToProto AccountReleaseSummary where
    type Output AccountReleaseSummary = Proto.ReleaseSchedule
    toProto ars = Proto.make $ do
        ProtoFields.total .= toProto (releaseTotal ars)
        ProtoFields.schedules .= (toProto <$> releaseSchedule ars)

instance ToProto ScheduledRelease where
    type Output ScheduledRelease = Proto.Release
    toProto r = Proto.make $ do
        ProtoFields.timestamp .= mkWord64 (releaseTimestamp r)
        ProtoFields.amount .= toProto (releaseAmount r)
        ProtoFields.transactions .= (toProto <$> releaseTransactions r)

instance ToProto (Timestamp, Amount) where
  type Output (Timestamp, Amount) = Proto.NewRelease
  toProto (t, a) = Proto.make $ do
      ProtoFields.timestamp . ProtoFields.value .= tsMillis t
      ProtoFields.amount .= toProto a

instance ToProto (StakePendingChange' UTCTime) where
    type Output (StakePendingChange' UTCTime) = Maybe Proto.StakePendingChange
    toProto NoChange = Nothing
    toProto (ReduceStake newStake effectiveTime) =
        Just . Proto.make $
            ( ProtoFields.reduce
                .= Proto.make
                    ( do
                        ProtoFields.newStake .= toProto newStake
                        ProtoFields.effectiveTime .= mkWord64 (utcTimeToTimestamp effectiveTime)
                    )
            )
    toProto (RemoveStake effectiveTime) =
        Just . Proto.make $ (ProtoFields.remove .= mkWord64 (utcTimeToTimestamp effectiveTime))

instance ToProto BakerInfo where
    type Output BakerInfo = Proto.BakerInfo
    toProto BakerInfo{..} =
        Proto.make
            ( do
                ProtoFields.bakerId .= mkWord64 _bakerIdentity
                ProtoFields.electionKey .= mkSerialize _bakerElectionVerifyKey
                ProtoFields.signatureKey .= mkSerialize _bakerSignatureVerifyKey
                ProtoFields.aggregationKey .= mkSerialize _bakerAggregationVerifyKey
            )

instance ToProto OpenStatus where
    type Output OpenStatus = Proto.OpenStatus
    toProto OpenForAll = Proto.OPEN_STATUS_OPEN_FOR_ALL
    toProto ClosedForNew = Proto.OPEN_STATUS_CLOSED_FOR_NEW
    toProto ClosedForAll = Proto.OPEN_STATUS_CLOSED_FOR_ALL

instance ToProto UrlText where
    type Output UrlText = Text
    toProto (UrlText s) = s

instance ToProto AmountFraction where
    type Output AmountFraction = Proto.AmountFraction
    toProto (AmountFraction ppht) = Proto.make (ProtoFields.partsPerHundredThousand .= fromIntegral ppht)

instance ToProto ElectionDifficulty where
    type Output ElectionDifficulty = Proto.ElectionDifficulty
    toProto (ElectionDifficulty ppht) = Proto.make $ ProtoFields.value . ProtoFields.partsPerHundredThousand .= fromIntegral ppht

instance ToProto CommissionRates where
    type Output CommissionRates = Proto.CommissionRates
    toProto CommissionRates{..} = Proto.make $ do
        ProtoFields.finalization .= toProto _finalizationCommission
        ProtoFields.baking .= toProto _bakingCommission
        ProtoFields.transaction .= toProto _transactionCommission

instance ToProto BakerPoolInfo where
    type Output BakerPoolInfo = Proto.BakerPoolInfo
    toProto BakerPoolInfo{..} = Proto.make $ do
        ProtoFields.openStatus .= toProto _poolOpenStatus
        ProtoFields.url .= toProto _poolMetadataUrl
        ProtoFields.commissionRates .= toProto _poolCommissionRates

instance ToProto AccountStakingInfo where
    type Output AccountStakingInfo = Maybe Proto.AccountStakingInfo
    toProto AccountStakingNone = Nothing
    toProto AccountStakingBaker{..} =
        Just . Proto.make $
            ( do
                ProtoFields.baker
                    .= Proto.make
                        ( do
                            ProtoFields.stakedAmount .= toProto asiStakedAmount
                            ProtoFields.restakeEarnings .= asiStakeEarnings
                            ProtoFields.bakerInfo .= toProto asiBakerInfo
                            ProtoFields.maybe'pendingChange .= toProto asiPendingChange
                            case asiPoolInfo of
                                Nothing -> return ()
                                Just asipi -> ProtoFields.poolInfo .= toProto asipi
                        )
            )
    toProto AccountStakingDelegated{..} =
        Just . Proto.make $
            ( do
                ProtoFields.delegator
                    .= Proto.make
                        ( do
                            ProtoFields.stakedAmount .= mkWord64 asiStakedAmount
                            ProtoFields.restakeEarnings .= asiStakeEarnings
                            ProtoFields.target .= toProto asiDelegationTarget
                            ProtoFields.maybe'pendingChange .= toProto asiDelegationPendingChange
                        )
            )

instance ToProto DelegationTarget where
  type Output DelegationTarget = Proto.DelegationTarget
  toProto DelegatePassive = Proto.make $ ProtoFields.passive .= Proto.defMessage
  toProto (DelegateToBaker bi) = Proto.make $ ProtoFields.baker .= toProto bi

instance ToProto (Map.Map CredentialIndex (Versioned RawAccountCredential)) where
    type Output (Map.Map CredentialIndex (Versioned RawAccountCredential)) = Map.Map Word32 Proto.AccountCredential
    toProto = Map.fromAscList . map (\(k, v) -> (fromIntegral k, toProto (vValue v))) . Map.toAscList

instance ToProto CredentialPublicKeys where
    type Output CredentialPublicKeys = Proto.CredentialPublicKeys
    toProto CredentialPublicKeys{..} = Proto.make $ do
        ProtoFields.threshold .= mkWord8 credThreshold
        ProtoFields.keys .= (Map.fromAscList . map convertKey . Map.toAscList $ credKeys)
      where
        convertKey (ki, VerifyKeyEd25519 key) = (fromIntegral ki, Proto.make $ ProtoFields.ed25519Key .= S.encode key)

instance ToProto Policy where
    type Output Policy = Proto.Policy
    toProto Policy{..} = Proto.make $ do
        ProtoFields.createdAt .= toProto pCreatedAt
        ProtoFields.validTo .= toProto pValidTo
        ProtoFields.attributes .= mkAttributes pItems
      where
        mkAttributes =
            Map.fromAscList
                . map (\(AttributeTag tag, value) -> (fromIntegral tag, S.runPut (S.putShortByteString (coerce value))))
                . Map.toAscList

instance ToProto YearMonth where
    type Output YearMonth = Proto.YearMonth
    toProto YearMonth{..} = Proto.make $ do
        ProtoFields.year .= fromIntegral ymYear
        ProtoFields.month .= fromIntegral ymMonth

instance ToProto RawCredentialRegistrationID where
    type Output RawCredentialRegistrationID = Proto.CredentialRegistrationId
    toProto = mkSerialize

instance ToProto CredentialRegistrationID where
  type Output CredentialRegistrationID = Proto.CredentialRegistrationId
  toProto = toProto . toRawCredRegId

instance ToProto IdentityProviderIdentity where
    type Output IdentityProviderIdentity = Proto.IdentityProviderIdentity
    toProto = mkWord32

instance ToProto Commitment where
    type Output Commitment = Proto.Commitment
    toProto = mkSerialize

instance ToProto CredentialDeploymentCommitments where
    type Output CredentialDeploymentCommitments = Proto.CredentialCommitments
    toProto CredentialDeploymentCommitments{..} = Proto.make $ do
        ProtoFields.prf .= toProto cmmPrf
        ProtoFields.credCounter .= toProto cmmCredCounter
        ProtoFields.maxAccounts .= toProto cmmMaxAccounts
        ProtoFields.attributes
            .= ( Map.fromAscList
                    . map (\(AttributeTag tag, v) -> (fromIntegral tag :: Word32, toProto v))
                    . Map.toAscList
               )
                cmmAttributes
        ProtoFields.idCredSecSharingCoeff .= map toProto cmmIdCredSecSharingCoeff

instance ToProto RawAccountCredential where
    type Output RawAccountCredential = Proto.AccountCredential
    toProto (InitialAC InitialCredentialDeploymentValues{..}) =
        Proto.make $
            ProtoFields.initial
                .= Proto.make
                    ( do
                        ProtoFields.keys .= toProto icdvAccount
                        ProtoFields.credId .= toProto icdvRegId
                        ProtoFields.ipId .= toProto icdvIpId
                        ProtoFields.policy .= toProto icdvPolicy
                    )
    toProto (NormalAC CredentialDeploymentValues{..} commitments) =
        Proto.make $
            ProtoFields.normal
                .= Proto.make
                    ( do
                        ProtoFields.keys .= toProto cdvPublicKeys
                        ProtoFields.credId .= toProto cdvCredId
                        ProtoFields.ipId .= toProto cdvIpId
                        ProtoFields.policy .= toProto cdvPolicy
                        ProtoFields.arThreshold .= toProto cdvThreshold
                        ProtoFields.commitments .= toProto commitments
                    )

instance ToProto AccountEncryptionKey where
    type Output AccountEncryptionKey = Proto.EncryptionKey
    toProto = mkSerialize

instance ToProto AccountInfo where
    type Output AccountInfo = Proto.AccountInfo
    toProto AccountInfo{..} = Proto.make $ do
        ProtoFields.sequenceNumber .= toProto aiAccountNonce
        ProtoFields.amount .= toProto aiAccountAmount
        ProtoFields.schedule .= toProto aiAccountReleaseSchedule
        ProtoFields.creds .= toProto aiAccountCredentials
        ProtoFields.threshold .= toProto aiAccountThreshold
        ProtoFields.encryptedBalance .= toProto aiAccountEncryptedAmount
        ProtoFields.encryptionKey .= toProto aiAccountEncryptionKey
        ProtoFields.index .= toProto aiAccountIndex
        ProtoFields.address .= toProto aiAccountAddress
        ProtoFields.maybe'stake .= toProto aiStakingInfo

instance ToProto Wasm.Parameter where
  type Output Wasm.Parameter = Proto.Parameter
  toProto Wasm.Parameter{..} = Proto.make $ ProtoFields.value .= BSS.fromShort parameter

instance ToProto RejectReason where
  type Output RejectReason = Proto.RejectReason
  toProto r = case r of
    ModuleNotWF -> Proto.make $ ProtoFields.moduleNotWf .= Proto.defMessage
    ModuleHashAlreadyExists moduleRef -> Proto.make $ ProtoFields.moduleHashAlreadyExists .= toProto moduleRef
    InvalidAccountReference addr -> Proto.make $ ProtoFields.invalidAccountReference .= toProto addr
    InvalidInitMethod moduleRef initName -> Proto.make $ ProtoFields.invalidInitMethod .= Proto.make (do
                                                                                            ProtoFields.moduleRef .= toProto moduleRef
                                                                                            ProtoFields.initName .= toProto initName)
    InvalidReceiveMethod moduleRef receiveName -> Proto.make $ ProtoFields.invalidReceiveMethod .= Proto.make (do
                                                                                            ProtoFields.moduleRef .= toProto moduleRef
                                                                                            ProtoFields.receiveName .= toProto receiveName)
    InvalidModuleReference moduleRef -> Proto.make $ ProtoFields.invalidModuleReference .= toProto moduleRef
    InvalidContractAddress addr -> Proto.make $ ProtoFields.invalidContractAddress .= toProto addr
    RuntimeFailure -> Proto.make $ ProtoFields.runtimeFailure .= Proto.defMessage
    AmountTooLarge addr amount -> Proto.make $ ProtoFields.amountTooLarge .= Proto.make (do
                                                                                         ProtoFields.address .= toProto addr
                                                                                         ProtoFields.amount .= toProto amount)
    SerializationFailure -> Proto.make $ ProtoFields.serializationFailure .= Proto.defMessage
    OutOfEnergy -> Proto.make $ ProtoFields.outOfEnergy .= Proto.defMessage
    RejectedInit{..} -> Proto.make $ ProtoFields.rejectedInit . ProtoFields.rejectReason .= rejectReason
    RejectedReceive{..} -> Proto.make $ ProtoFields.rejectedReceive .= Proto.make (do
                                                                        ProtoFields.rejectReason .= rejectReason
                                                                        ProtoFields.contractAddress .= toProto contractAddress
                                                                        ProtoFields.receiveName .= toProto receiveName
                                                                        ProtoFields.parameter .= toProto parameter)
    InvalidProof -> Proto.make $ ProtoFields.invalidProof .= Proto.defMessage
    AlreadyABaker bakerId -> Proto.make $ ProtoFields.alreadyABaker .= toProto bakerId
    NotABaker addr -> Proto.make $ ProtoFields.notABaker .= toProto addr
    InsufficientBalanceForBakerStake -> Proto.make $ ProtoFields.insufficientBalanceForBakerStake .= Proto.defMessage
    StakeUnderMinimumThresholdForBaking -> Proto.make $ ProtoFields.stakeUnderMinimumThresholdForBaking .= Proto.defMessage
    BakerInCooldown -> Proto.make $ ProtoFields.bakerInCooldown .= Proto.defMessage
    DuplicateAggregationKey k -> Proto.make $ ProtoFields.duplicateAggregationKey .= mkSerialize k
    NonExistentCredentialID -> Proto.make $ ProtoFields.nonExistentCredentialId .= Proto.defMessage
    KeyIndexAlreadyInUse -> Proto.make $ ProtoFields.keyIndexAlreadyInUse .= Proto.defMessage
    InvalidAccountThreshold -> Proto.make $ ProtoFields.invalidAccountThreshold .= Proto.defMessage
    InvalidCredentialKeySignThreshold -> Proto.make $ ProtoFields.invalidCredentialKeySignThreshold .= Proto.defMessage
    InvalidEncryptedAmountTransferProof -> Proto.make $ ProtoFields.invalidEncryptedAmountTransferProof .= Proto.defMessage
    InvalidTransferToPublicProof -> Proto.make $ ProtoFields.invalidTransferToPublicProof .= Proto.defMessage
    EncryptedAmountSelfTransfer addr -> Proto.make $ ProtoFields.encryptedAmountSelfTransfer .= toProto addr
    InvalidIndexOnEncryptedTransfer -> Proto.make $ ProtoFields.invalidIndexOnEncryptedTransfer .= Proto.defMessage
    ZeroScheduledAmount -> Proto.make $ ProtoFields.zeroScheduledAmount .= Proto.defMessage
    NonIncreasingSchedule -> Proto.make $ ProtoFields.nonIncreasingSchedule .= Proto.defMessage
    FirstScheduledReleaseExpired -> Proto.make $ ProtoFields.firstScheduledReleaseExpired .= Proto.defMessage
    ScheduledSelfTransfer addr -> Proto.make $ ProtoFields.scheduledSelfTransfer .= toProto addr
    InvalidCredentials -> Proto.make $ ProtoFields.invalidCredentials .= Proto.defMessage
    DuplicateCredIDs ids -> Proto.make $ ProtoFields.duplicateCredIds . ProtoFields.ids .= (toProto <$> ids)
    NonExistentCredIDs ids -> Proto.make $ ProtoFields.nonExistentCredIds . ProtoFields.ids .= (toProto <$> ids)
    RemoveFirstCredential -> Proto.make $ ProtoFields.removeFirstCredential .= Proto.defMessage
    CredentialHolderDidNotSign -> Proto.make $ ProtoFields.credentialHolderDidNotSign .= Proto.defMessage
    NotAllowedMultipleCredentials -> Proto.make $ ProtoFields.notAllowedMultipleCredentials .= Proto.defMessage
    NotAllowedToReceiveEncrypted -> Proto.make $ ProtoFields.notAllowedToReceiveEncrypted .= Proto.defMessage
    NotAllowedToHandleEncrypted -> Proto.make $ ProtoFields.notAllowedToHandleEncrypted .= Proto.defMessage
    MissingBakerAddParameters -> Proto.make $ ProtoFields.missingBakerAddParameters .= Proto.defMessage
    FinalizationRewardCommissionNotInRange -> Proto.make $ ProtoFields.finalizationRewardCommissionNotInRange .= Proto.defMessage
    BakingRewardCommissionNotInRange -> Proto.make $ ProtoFields.bakingRewardCommissionNotInRange .= Proto.defMessage
    TransactionFeeCommissionNotInRange -> Proto.make $ ProtoFields.transactionFeeCommissionNotInRange .= Proto.defMessage
    AlreadyADelegator -> Proto.make $ ProtoFields.alreadyADelegator .= Proto.defMessage
    InsufficientBalanceForDelegationStake -> Proto.make $ ProtoFields.insufficientBalanceForDelegationStake .= Proto.defMessage
    MissingDelegationAddParameters -> Proto.make $ ProtoFields.missingDelegationAddParameters .= Proto.defMessage
    InsufficientDelegationStake -> Proto.make $ ProtoFields.insufficientDelegationStake .= Proto.defMessage
    DelegatorInCooldown -> Proto.make $ ProtoFields.delegatorInCooldown .= Proto.defMessage
    NotADelegator addr -> Proto.make $ ProtoFields.notADelegator .= toProto addr
    DelegationTargetNotABaker bakerId -> Proto.make $ ProtoFields.delegationTargetNotABaker .= toProto bakerId
    StakeOverMaximumThresholdForPool -> Proto.make $ ProtoFields.stakeOverMaximumThresholdForPool .= Proto.defMessage
    PoolWouldBecomeOverDelegated -> Proto.make $ ProtoFields.poolWouldBecomeOverDelegated .= Proto.defMessage
    PoolClosed -> Proto.make $ ProtoFields.poolClosed .= Proto.defMessage

-- |Attempt to convert the node's TransactionStatus type into the protobuf BlockItemStatus type.
--  The protobuf type is better structured and removes the need for handling impossible cases.
--  For example the case of an account transfer resulting in a smart contract update, which is a
--  technical possibility in the way that the node's trx status is defined.
toBlockItemStatus :: QueryTypes.TransactionStatus -> Either ConversionError Proto.BlockItemStatus
toBlockItemStatus ts = case ts of
  QueryTypes.Received -> Right . Proto.make $ ProtoFields.received .= Proto.defMessage
  QueryTypes.Finalized bh trx -> do
    bis <- toBis trx
    trxInBlock <- toTrxInBlock bh bis
    Right . Proto.make $ ProtoFields.finalized . ProtoFields.outcome .= trxInBlock
  QueryTypes.Committed trxs -> do
    outcomes <- mapM (\(bh, trx) -> toTrxInBlock bh =<< toBis trx) $ Map.toList trxs
    Right . Proto.make $ ProtoFields.committed . ProtoFields.outcomes .= outcomes
  where
    -- |Convert a transaction summary to a proto block item summary.
    --  The transaction summary can technically be Nothing, but it should never occur.
    toBis :: Maybe TransactionSummary -> Either ConversionError Proto.BlockItemSummary
    toBis Nothing = Left CEInvalidTransactionResult
    toBis (Just t) = toBlockItemSummary t

    toTrxInBlock bh bis = Right . Proto.make $ do
      ProtoFields.blockHash .= toProto bh
      ProtoFields.outcome .= bis

-- |Attempt to convert a TransactionSummary type into the protobuf BlockItemSummary type.
--  See @toBlockItemStatus@ for more context.
toBlockItemSummary :: TransactionSummary -> Either ConversionError Proto.BlockItemSummary
toBlockItemSummary TransactionSummary{..} = case tsType of
    TSTAccountTransaction tty -> do
        sender <- case tsSender of
            Nothing -> Left CEInvalidTransactionResult
            Just acc -> Right acc
        details <- convertAccountTransaction tty tsCost sender tsResult
        Right . Proto.make $ do
            ProtoFields.index .= mkWord64 tsIndex
            ProtoFields.energyCost .= toProto tsEnergyCost
            ProtoFields.hash .= toProto tsHash
            ProtoFields.accountTransaction .= details
    TSTCredentialDeploymentTransaction ct -> case tsResult of
        TxReject _ -> Left CEFailedAccountCreation
        TxSuccess events -> case events of
            [AccountCreated addr, CredentialDeployed{..}] -> let
                details = Proto.make $ do
                    ProtoFields.credentialType .= toProto ct
                    ProtoFields.address .= toProto addr
                    ProtoFields.regId .= toProto ecdRegId
                in Right . Proto.make $ do
                    ProtoFields.index .= mkWord64 tsIndex
                    ProtoFields.energyCost .= toProto tsEnergyCost
                    ProtoFields.hash .= toProto tsHash
                    ProtoFields.accountCreation .= details
            _ -> Left CEInvalidAccountCreation
    TSTUpdateTransaction ut -> case tsResult of
        TxReject _ -> Left CEFailedUpdate
        TxSuccess events -> case events of
            [UpdateEnqueued{..}] -> do
                payload <- convertUpdatePayload ut uePayload
                details <- Right . Proto.make $ do
                    ProtoFields.effectiveTime .= toProto ueEffectiveTime
                    ProtoFields.payload .= payload
                Right . Proto.make $ do
                    ProtoFields.index .= mkWord64 tsIndex
                    ProtoFields.energyCost .= toProto tsEnergyCost
                    ProtoFields.hash .= toProto tsHash
                    ProtoFields.update .= details
            _ -> Left CEInvalidUpdateResult

-- |Attempt to construct the protobuf updatepayload.
--  See @toBlockItemStatus@ for more context.
convertUpdatePayload :: Updates.UpdateType -> Updates.UpdatePayload -> Either ConversionError Proto.UpdatePayload
convertUpdatePayload ut pl = case (ut, pl) of
    (Updates.UpdateProtocol, Updates.ProtocolUpdatePayload Updates.ProtocolUpdate{..}) -> Right . Proto.make $ ProtoFields.protocolUpdate .= Proto.make (do
            ProtoFields.message .= puMessage
            ProtoFields.specificationUrl .= puSpecificationURL
            ProtoFields.specificationHash .= toProto puSpecificationHash
            ProtoFields.specificationAuxiliaryData .= puSpecificationAuxiliaryData)
    (Updates.UpdateElectionDifficulty, Updates.ElectionDifficultyUpdatePayload ed) -> Right . Proto.make $ ProtoFields.electionDifficultyUpdate .= toProto ed
    (Updates.UpdateEuroPerEnergy, Updates.EuroPerEnergyUpdatePayload er) -> Right . Proto.make $ ProtoFields.euroPerEnergyUpdate .= toProto er
    (Updates.UpdateMicroGTUPerEuro, Updates.MicroGTUPerEuroUpdatePayload er) -> Right . Proto.make $ ProtoFields.microCcdPerEuroUpdate .= toProto er
    (Updates.UpdateFoundationAccount, Updates.FoundationAccountUpdatePayload addr) -> Right . Proto.make $ ProtoFields.foundationAccountUpdate .= toProto addr
    (Updates.UpdateMintDistribution, Updates.MintDistributionUpdatePayload md) -> Right . Proto.make $ ProtoFields.mintDistributionUpdate .= Proto.make (do
        ProtoFields.mintDistribution .= toProto (md ^. Parameters.mdMintPerSlot . Parameters.mpsMintPerSlot)
        ProtoFields.bakingReward .= toProto (Parameters._mdBakingReward md)
        ProtoFields.finalizationReward .= toProto (Parameters._mdFinalizationReward md))
    (Updates.UpdateTransactionFeeDistribution, Updates.TransactionFeeDistributionUpdatePayload Parameters.TransactionFeeDistribution{..}) -> Right . Proto.make $ ProtoFields.transactionFeeDistributionUpdate .= Proto.make (do
        ProtoFields.baker .= toProto _tfdBaker
        ProtoFields.gasAccount .= toProto _tfdGASAccount)
    (Updates.UpdateGASRewards, Updates.GASRewardsUpdatePayload Parameters.GASRewards{..}) -> Right . Proto.make $ ProtoFields.gasRewardsUpdate .= Proto.make (do
        ProtoFields.baker .= toProto _gasBaker
        ProtoFields.finalizationProof .= toProto _gasFinalizationProof
        ProtoFields.accountCreation .= toProto _gasAccountCreation
        ProtoFields.chainUpdate .= toProto _gasChainUpdate)
    (Updates.UpdatePoolParameters, Updates.BakerStakeThresholdUpdatePayload pp) -> Right . Proto.make $
        ProtoFields.bakerStakeThresholdUpdate . ProtoFields.bakerStakeThreshold .= toProto (pp ^. Parameters.ppBakerStakeThreshold)
    (Updates.UpdateRootKeys, Updates.RootUpdatePayload ru@(Updates.RootKeysRootUpdate{})) -> Right . Proto.make $ ProtoFields.rootUpdate .= toProto ru
    (Updates.UpdateLevel1Keys, Updates.RootUpdatePayload ru@(Updates.Level1KeysRootUpdate{})) -> Right . Proto.make $ ProtoFields.rootUpdate .= toProto ru
    (Updates.UpdateLevel2Keys, Updates.RootUpdatePayload ru@(Updates.Level2KeysRootUpdate{})) -> Right . Proto.make $ ProtoFields.rootUpdate .= toProto ru
    (Updates.UpdateLevel2Keys, Updates.RootUpdatePayload ru@(Updates.Level2KeysRootUpdateV1{})) -> Right . Proto.make $ ProtoFields.rootUpdate .= toProto ru
    (Updates.UpdateLevel1Keys, Updates.Level1UpdatePayload u@(Updates.Level1KeysLevel1Update{})) -> Right . Proto.make $ ProtoFields.level1Update .= toProto u
    (Updates.UpdateLevel2Keys, Updates.Level1UpdatePayload u@(Updates.Level2KeysLevel1Update{})) -> Right . Proto.make $ ProtoFields.level1Update .= toProto u
    (Updates.UpdateLevel2Keys, Updates.Level1UpdatePayload u@(Updates.Level2KeysLevel1UpdateV1{})) -> Right . Proto.make $ ProtoFields.level1Update .= toProto u
    (Updates.UpdateAddAnonymityRevoker, Updates.AddAnonymityRevokerUpdatePayload ai) -> Right . Proto.make $ ProtoFields.addAnonymityRevokerUpdate .= toProto ai
    (Updates.UpdateAddIdentityProvider, Updates.AddIdentityProviderUpdatePayload ip) -> Right . Proto.make $ ProtoFields.addIdentityProviderUpdate .= toProto ip
    (Updates.UpdateCooldownParameters, Updates.CooldownParametersCPV1UpdatePayload cp) -> Right $ case cp of
        Parameters.CooldownParametersV1{..} -> Proto.make $ ProtoFields.cooldownParametersCpv1Update .= Proto.make (do
            ProtoFields.poolOwnerCooldown .= toProto _cpPoolOwnerCooldown
            ProtoFields.delegatorCooldown .= toProto _cpDelegatorCooldown)
    (Updates.UpdatePoolParameters, Updates.PoolParametersCPV1UpdatePayload pp) -> Right . Proto.make $ ProtoFields.poolParametersCpv1Update .= Proto.make (do
            ProtoFields.passiveFinalizationCommission .= toProto (pp ^. Parameters.ppPassiveCommissions . finalizationCommission)
            ProtoFields.passiveBakingCommission .= toProto (pp ^. Parameters.ppPassiveCommissions . bakingCommission)
            ProtoFields.passiveTransactionCommission .= toProto (pp ^. Parameters.ppPassiveCommissions . transactionCommission)
            ProtoFields.commissionBounds .= Proto.make (do
                ProtoFields.finalization .= toProto (pp ^. Parameters.ppCommissionBounds . Parameters.finalizationCommissionRange)
                ProtoFields.baking.= toProto (pp ^. Parameters.ppCommissionBounds . Parameters.bakingCommissionRange)
                ProtoFields.transaction .= toProto (pp ^. Parameters.ppCommissionBounds . Parameters.transactionCommissionRange))
            ProtoFields.minimumEquityCapital .= toProto (pp ^. Parameters.ppMinimumEquityCapital)
            ProtoFields.capitalBound .= toProto (pp ^. Parameters.ppCapitalBound)
            ProtoFields.leverageBound .= toProto (pp ^. Parameters.ppLeverageBound))
    (Updates.UpdateTimeParameters, Updates.TimeParametersCPV1UpdatePayload tp) -> Right $ case tp of
        Parameters.TimeParametersV1{..} -> Proto.make $ ProtoFields.timeParametersCpv1Update .= Proto.make (do
            ProtoFields.rewardPeriodLength .= toProto _tpRewardPeriodLength
            ProtoFields.mintPerPayday .= toProto _tpMintPerPayday)
    (Updates.UpdateMintDistribution, Updates.MintDistributionCPV1UpdatePayload md) -> Right . Proto.make $ ProtoFields.mintDistributionCpv1Update .= Proto.make (do
        ProtoFields.bakingReward .= toProto (Parameters._mdBakingReward md)
        ProtoFields.finalizationReward .= toProto (Parameters._mdFinalizationReward md))
    _ -> Left CEInvalidUpdateResult

-- |The different conversions errors possible in @toBlockItemStatus@ (and the helper to* functions it calls).
data ConversionError
  -- |An account creation failed.
  = CEFailedAccountCreation
  -- |An account creation transaction occurred but was malformed and could not be converted.
  | CEInvalidAccountCreation
  -- |An update transaction failed.
  | CEFailedUpdate
  -- |An update transaction occurred but was malformed and could not be converted.
  | CEInvalidUpdateResult
  -- |An account transaction occurred but was malformed and could not be converted.
  | CEInvalidTransactionResult
  deriving (Eq, Show)

instance ToProto TransactionTime where
  type Output TransactionTime = Proto.TransactionTime
  toProto = mkWord64

instance ToProto ExchangeRate where
  type Output ExchangeRate = Proto.ExchangeRate
  toProto (ExchangeRate r) = Proto.make $ ProtoFields.value .= toProto r

instance ToProto (Ratio.Ratio Word64) where
  type Output (Ratio.Ratio Word64) = Proto.Ratio
  toProto r = Proto.make $ do
     ProtoFields.numerator .= Ratio.numerator r
     ProtoFields.denominator .= Ratio.denominator r

instance ToProto (Parameters.InclusiveRange AmountFraction) where
  type Output (Parameters.InclusiveRange AmountFraction)= Proto.InclusiveRangeAmountFraction
  toProto Parameters.InclusiveRange{..} = Proto.make $ do
    ProtoFields.min .= toProto irMin
    ProtoFields.max .= toProto irMax

instance ToProto Parameters.CapitalBound where
  type Output Parameters.CapitalBound = Proto.CapitalBound
  toProto Parameters.CapitalBound{..} = Proto.make $ ProtoFields.value .= toProto theCapitalBound

instance ToProto Parameters.LeverageFactor where
  type Output Parameters.LeverageFactor = Proto.LeverageFactor
  toProto Parameters.LeverageFactor{..} = Proto.make $ ProtoFields.value .= toProto theLeverageFactor

instance ToProto RewardPeriodLength where
  type Output RewardPeriodLength = Proto.RewardPeriodLength
  toProto rpl = Proto.make $ ProtoFields.value .= mkWord64 rpl

instance ToProto DurationSeconds where
  type Output DurationSeconds = Proto.DurationSeconds
  toProto = mkWord64

instance ToProto ArInfo.ArInfo where
  type Output ArInfo.ArInfo = Proto.ArInfo
  toProto ai = Proto.make $ do
    ProtoFields.identity .= mkWord32 (ArInfo.arIdentity ai)
    ProtoFields.description .= Proto.make (do
      ProtoFields.name .= ArInfo.arName ai
      ProtoFields.url .= ArInfo.arUrl ai
      ProtoFields.description .= ArInfo.arDescription ai)
    ProtoFields.publicKey . ProtoFields.value .= ArInfo.arPublicKey ai

instance ToProto IpInfo.IpInfo where
  type Output IpInfo.IpInfo = Proto.IpInfo
  toProto ii = Proto.make $ do
    ProtoFields.identity .= mkWord32 (IpInfo.ipIdentity ii)
    ProtoFields.description .= Proto.make (do
      ProtoFields.name .= IpInfo.ipName ii
      ProtoFields.url .= IpInfo.ipUrl ii
      ProtoFields.description .= IpInfo.ipDescription ii)
    ProtoFields.verifyKey . ProtoFields.value .= IpInfo.ipVerifyKey ii
    ProtoFields.cdiVerifyKey . ProtoFields.value .= IpInfo.ipCdiVerifyKey ii

instance ToProto Updates.Level1Update where
  type Output Updates.Level1Update = Proto.UpdatePayload'Level1UpdatePayload
  toProto Updates.Level1KeysLevel1Update{..} = Proto.make $ ProtoFields.level1KeysUpdate .= toProto l1kl1uKeys
  toProto Updates.Level2KeysLevel1Update{..} = Proto.make $ ProtoFields.level2KeysUpdateV0 .= toProto l2kl1uAuthorizations
  toProto Updates.Level2KeysLevel1UpdateV1{..} = Proto.make $ ProtoFields.level2KeysUpdateV1 .= toProto l2kl1uAuthorizationsV1

instance ToProto Updates.RootUpdate where
  type Output Updates.RootUpdate = Proto.UpdatePayload'RootUpdatePayload
  toProto ru = case ru of
    Updates.RootKeysRootUpdate{..} -> Proto.make $ ProtoFields.rootKeysUpdate .= toProto rkruKeys
    Updates.Level1KeysRootUpdate{..} -> Proto.make $ ProtoFields.level1KeysUpdate .= toProto l1kruKeys
    Updates.Level2KeysRootUpdate{..} -> Proto.make $ ProtoFields.level2KeysUpdateV0 .= toProto l2kruAuthorizations
    Updates.Level2KeysRootUpdateV1{..} -> Proto.make $ ProtoFields.level2KeysUpdateV1 .= toProto l2kruAuthorizationsV1

instance ToProto (Updates.HigherLevelKeys kind) where
  type Output (Updates.HigherLevelKeys kind) = Proto.HigherLevelKeys
  toProto keys = Proto.make $ do
    ProtoFields.keys .= map toProto (Vec.toList $ Updates.hlkKeys keys)
    ProtoFields.threshold .= toProto (Updates.hlkThreshold keys)

instance IsChainParametersVersion cpv => ToProto (Updates.Authorizations cpv) where
  type Output (Updates.Authorizations cpv) = AuthorizationsFamily cpv
  toProto auth = let
    v0 :: Proto.AuthorizationsV0
    v0 = Proto.make $ do
      ProtoFields.keys .= map toProto (Vec.toList $ Updates.asKeys auth)
      ProtoFields.emergency .= toProto (Updates.asEmergency auth)
      ProtoFields.protocol .= toProto (Updates.asProtocol auth)
      ProtoFields.parameterElectionDifficulty .= toProto (Updates.asParamElectionDifficulty auth)
      ProtoFields.parameterEuroPerEnergy.= toProto (Updates.asParamEuroPerEnergy auth)
      ProtoFields.parameterMicroCCDPerEuro .= toProto (Updates.asParamMicroGTUPerEuro auth)
      ProtoFields.parameterFoundationAccount .= toProto (Updates.asParamFoundationAccount auth)
      ProtoFields.parameterMintDistribution .= toProto (Updates.asParamMintDistribution auth)
      ProtoFields.parameterTransactionFeeDistribution .= toProto (Updates.asParamTransactionFeeDistribution auth)
      ProtoFields.parameterGasRewards .= toProto (Updates.asParamGASRewards auth)
      ProtoFields.poolParameters .= toProto (Updates.asPoolParameters auth)
      ProtoFields.addAnonymityRevoker .= toProto (Updates.asAddAnonymityRevoker auth)
      ProtoFields.addIdentityProvider .= toProto (Updates.asAddIdentityProvider auth)
    in case chainParametersVersion @cpv of
        SCPV0 -> v0
        SCPV1 -> Proto.make $ do
          ProtoFields.v0 .= v0
          case Updates.asCooldownParameters auth of
            JustForCPV1 as -> ProtoFields.parameterCooldown .= toProto as
          case Updates.asTimeParameters auth of
            JustForCPV1 as -> ProtoFields.parameterTime .= toProto as

-- |Defines a type family that is used in the ToProto instance for Updates.Authorizations.
type family AuthorizationsFamily cpv where
  AuthorizationsFamily 'ChainParametersV0 = Proto.AuthorizationsV0
  AuthorizationsFamily 'ChainParametersV1 = Proto.AuthorizationsV1

instance ToProto Updates.AccessStructure where
  type Output Updates.AccessStructure = Proto.AccessStructure
  toProto Updates.AccessStructure{..} = Proto.make $ do
    ProtoFields.accessPublicKeys .= map toProtoUpdateKeysIndex (Set.toList accessPublicKeys)
    ProtoFields.accessThreshold .= toProto accessThreshold
    where toProtoUpdateKeysIndex i = Proto.make $ ProtoFields.value .= fromIntegral i

instance ToProto Updates.UpdatePublicKey where
  type Output Updates.UpdatePublicKey = Proto.UpdatePublicKey
  toProto (VerifyKeyEd25519 key) = Proto.make $ ProtoFields.value .= S.encode key

instance ToProto Updates.UpdateKeysThreshold where
  type Output Updates.UpdateKeysThreshold = Proto.UpdateKeysThreshold
  toProto Updates.UpdateKeysThreshold{..} = Proto.make $ ProtoFields.value .= fromIntegral uktTheThreshold

instance ToProto MintRate where
  type Output MintRate = Proto.MintRate
  toProto MintRate{..} = Proto.make $ do
    ProtoFields.mantissa .= mrMantissa
    ProtoFields.exponent .= fromIntegral mrExponent

instance ToProto Wasm.WasmVersion where
  type Output Wasm.WasmVersion = Proto.ContractVersion
  toProto Wasm.V0 = Proto.V0
  toProto Wasm.V1 = Proto.V1

instance ToProto Wasm.ContractEvent where
  type Output Wasm.ContractEvent = Proto.ContractEvent
  toProto (Wasm.ContractEvent shortBS) = Proto.make $ ProtoFields.value .= BSS.fromShort shortBS

instance ToProto CredentialType where
  type Output CredentialType = Proto.CredentialType
  toProto Initial = Proto.CREDENTIAL_TYPE_INITIAL
  toProto Normal = Proto.CREDENTIAL_TYPE_NORMAL

type BakerAddedEvent = (BakerKeysEvent, Amount, Bool)

instance ToProto BakerAddedEvent where
  type Output BakerAddedEvent = Proto.BakerEvent'BakerAdded
  toProto (keysEvent, stake, restakeEarnings) = Proto.make $ do
    ProtoFields.keysEvent .= toProto keysEvent
    ProtoFields.stake .= toProto stake
    ProtoFields.restakeEarnings .= restakeEarnings

type BakerKeysEvent = (BakerId, AccountAddress, BakerSignVerifyKey, BakerElectionVerifyKey, BakerAggregationVerifyKey)
instance ToProto BakerKeysEvent where
  type Output BakerKeysEvent = Proto.BakerKeysEvent
  toProto (bakerId, addr, signKey, electionKey, aggregationKey) = Proto.make $ do
    ProtoFields.bakerId .= toProto bakerId
    ProtoFields.account .= toProto addr
    ProtoFields.signKey .= toProto signKey
    ProtoFields.electionKey .= toProto electionKey
    ProtoFields.aggregationKey .= toProto aggregationKey

instance ToProto BakerSignVerifyKey where
  type Output BakerSignVerifyKey = Proto.BakerSignatureVerifyKey
  toProto = mkSerialize

instance ToProto BakerElectionVerifyKey where
  type Output BakerElectionVerifyKey = Proto.BakerElectionVerifyKey
  toProto = mkSerialize

instance ToProto BakerAggregationVerifyKey where
  type Output BakerAggregationVerifyKey = Proto.BakerAggregationVerifyKey
  toProto = mkSerialize

instance ToProto Memo where
  type Output Memo = Proto.Memo
  toProto (Memo shortBS) = Proto.make $ ProtoFields.value .= BSS.fromShort shortBS

instance ToProto RegisteredData where
  type Output RegisteredData = Proto.RegisteredData
  toProto (RegisteredData shortBS) = Proto.make $ ProtoFields.value .= BSS.fromShort shortBS

convertContractRelatedEvents :: Event -> Either ConversionError Proto.ContractTraceElement
convertContractRelatedEvents event = case event of
    Updated{..} -> Right . Proto.make $ ProtoFields.updated .= Proto.make (do
      ProtoFields.contractVersion .= toProto euContractVersion
      ProtoFields.address .= toProto euAddress
      ProtoFields.instigator .= toProto euInstigator
      ProtoFields.amount .= toProto euAmount
      ProtoFields.parameter .= toProto euMessage
      ProtoFields.receiveName .= toProto euReceiveName
      ProtoFields.events .= map toProto euEvents)
    Transferred{..} -> do
      sender' <- case etFrom of
        AddressAccount _ -> Left CEInvalidTransactionResult
        AddressContract addr -> Right addr
      receiver <- case etTo of
        AddressAccount addr -> Right addr
        AddressContract _ -> Left CEInvalidTransactionResult
      Right . Proto.make $ ProtoFields.transferred .= Proto.make (do
        ProtoFields.sender .= toProto sender'
        ProtoFields.amount .= toProto etAmount
        ProtoFields.receiver .= toProto receiver)
    Interrupted{..} -> Right . Proto.make $ ProtoFields.interrupted .= Proto.make (do
      ProtoFields.address .= toProto iAddress
      ProtoFields.events .= map toProto iEvents)
    Resumed{..} -> Right . Proto.make $ ProtoFields.resumed .= Proto.make (do
      ProtoFields.address .= toProto rAddress
      ProtoFields.success .= rSuccess)
    _ -> Left CEInvalidTransactionResult

-- |Attempt to construct the protobuf type AccounTransactionType.
-- See @toBlockItemStatus@ for more context.
convertAccountTransaction
  :: Maybe TransactionType -- ^ The transaction type. @Nothing@ means that the transaction was serialized incorrectly.
  -> Amount -- ^ The cost of the transaction.
  -> AccountAddress -- ^ The sender of the transaction.
  -> ValidResult -- ^ The result of the transaction. If the transaction was rejected, it contains the reject reason.
                 --   Otherwise it contains the events.
  -> Either ConversionError Proto.AccountTransactionDetails
convertAccountTransaction ty cost sender result = case ty of
    Nothing -> Right . mkNone $ SerializationFailure
    Just ty' -> case result of
        TxReject rejectReason -> Right . mkNone $ rejectReason
        TxSuccess events -> case ty' of
            TTDeployModule -> mkSuccess <$> do
                v <- case events of
                    [ModuleDeployed moduleRef] -> Right $ toProto moduleRef
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.moduleDeployed .= v
            TTInitContract -> mkSuccess <$> do
                v <- case events of
                    [ContractInitialized {..}] -> Right $ Proto.make $ do
                       ProtoFields.contractVersion .= toProto ecContractVersion
                       ProtoFields.originRef .= toProto ecRef
                       ProtoFields.address .= toProto ecAddress
                       ProtoFields.amount .= toProto ecAmount
                       ProtoFields.initName .= toProto ecInitName
                       ProtoFields.events .= map toProto ecEvents
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.contractInitialized .= v
            TTUpdate-> mkSuccess <$> do
                v <- mapM convertContractRelatedEvents events
                Right . Proto.make $ ProtoFields.contractUpdateIssued . ProtoFields.effects .= v
            TTTransfer-> mkSuccess <$> do
                v <- case events of
                    [Transferred{..}] -> case etTo of
                        AddressContract _ -> Left CEInvalidTransactionResult
                        AddressAccount receiver -> Right . Proto.make $ do
                            ProtoFields.amount .= toProto etAmount
                            ProtoFields.receiver .= toProto receiver
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.accountTransfer .= v
            TTTransferWithMemo -> mkSuccess <$> do
                v <- case events of
                    [Transferred{..}, TransferMemo{..}] -> case etTo of
                        AddressContract _ -> Left CEInvalidTransactionResult
                        AddressAccount receiver -> Right . Proto.make $ do
                            ProtoFields.amount .= toProto etAmount
                            ProtoFields.receiver .= toProto receiver
                            ProtoFields.memo .= toProto tmMemo
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.accountTransfer .= v
            TTAddBaker -> mkSuccess <$> do
                v <- case events of
                    [BakerAdded{..}] -> Right $ toProto ((ebaBakerId, ebaAccount, ebaSignKey, ebaElectionKey, ebaAggregationKey), ebaStake, ebaRestakeEarnings)
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerAdded .= v
            TTRemoveBaker -> mkSuccess <$> do
                v <- case events of
                    [BakerRemoved{..}] -> Right $ toProto ebrBakerId
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerRemoved .= v
            TTUpdateBakerStake -> mkSuccess <$> do
                v <- case events of
                    [] -> Right Proto.defMessage
                    [BakerStakeIncreased{..}] -> Right . Proto.make $ do
                        ProtoFields.bakerId .= toProto ebsiBakerId
                        ProtoFields.newStake .= toProto ebsiNewStake
                        ProtoFields.increased .= True
                    [BakerStakeDecreased{..}] -> Right . Proto.make $ do
                        ProtoFields.bakerId .= toProto ebsiBakerId
                        ProtoFields.newStake .= toProto ebsiNewStake
                        ProtoFields.increased .= False
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerStakeUpdated . ProtoFields.update .= v
            TTUpdateBakerRestakeEarnings -> mkSuccess <$> do
                v <- case events of
                    [BakerSetRestakeEarnings{..}] -> Right $ Proto.make $ do
                        ProtoFields.bakerId .= toProto ebsreBakerId
                        ProtoFields.restakeEarnings .= ebsreRestakeEarnings
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerRestakeEarningsUpdated .= v
            TTUpdateBakerKeys -> mkSuccess <$> do
                v <- case events of
                    [BakerKeysUpdated{..}] -> Right $ toProto (ebkuBakerId, ebkuAccount, ebkuSignKey, ebkuElectionKey, ebkuAggregationKey)
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerKeysUpdated .= v
            TTEncryptedAmountTransfer -> mkSuccess <$> do
                v <- case events of
                    [EncryptedAmountsRemoved{..}, NewEncryptedAmount{..}] -> let
                        removed = Proto.make $ do
                            ProtoFields.account .= toProto earAccount
                            ProtoFields.newAmount .= toProto earNewAmount
                            ProtoFields.inputAmount .= toProto earInputAmount
                            ProtoFields.upToIndex .= theAggIndex earUpToIndex
                        added = Proto.make $ do
                            ProtoFields.receiver .= toProto neaAccount
                            ProtoFields.newIndex .= theIndex neaNewIndex
                            ProtoFields.encryptedAmount .= toProto neaEncryptedAmount
                        in Right . Proto.make $ do
                            ProtoFields.removed .= removed
                            ProtoFields.added .= added
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.encryptedAmountTransferred .= v
            TTEncryptedAmountTransferWithMemo -> mkSuccess <$> do
                v <- case events of
                    [EncryptedAmountsRemoved{..}, NewEncryptedAmount{..}, TransferMemo{..}] -> let
                        removed = Proto.make $ do
                            ProtoFields.account .= toProto earAccount
                            ProtoFields.newAmount .= toProto earNewAmount
                            ProtoFields.inputAmount .= toProto earInputAmount
                            ProtoFields.upToIndex .= theAggIndex earUpToIndex
                        added = Proto.make $ do
                            ProtoFields.receiver .= toProto neaAccount
                            ProtoFields.newIndex .= theIndex neaNewIndex
                            ProtoFields.encryptedAmount .= toProto neaEncryptedAmount
                        in Right . Proto.make $ do
                            ProtoFields.removed .= removed
                            ProtoFields.added .= added
                            ProtoFields.memo .= toProto tmMemo
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.encryptedAmountTransferred .= v
            TTTransferToEncrypted -> mkSuccess <$> do
                v <- case events of
                    [EncryptedSelfAmountAdded{..}] -> Right . Proto.make $ do
                        ProtoFields.account .= toProto eaaAccount
                        ProtoFields.newAmount .= toProto eaaNewAmount
                        ProtoFields.amount .= toProto eaaAmount
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredToEncrypted .= v
            TTTransferToPublic -> mkSuccess <$> do
                v <- case events of
                    [EncryptedAmountsRemoved{..}, AmountAddedByDecryption{..}] -> let
                        removed = Proto.make $ do
                            ProtoFields.account .= toProto earAccount
                            ProtoFields.newAmount .= toProto earNewAmount
                            ProtoFields.inputAmount .= toProto earInputAmount
                            ProtoFields.upToIndex .= theAggIndex earUpToIndex
                        in Right . Proto.make $ do
                            ProtoFields.removed .= removed
                            ProtoFields.amount .= toProto aabdAmount
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredToPublic .= v
            TTTransferWithSchedule -> mkSuccess <$> do
                v <- case events of
                    [TransferredWithSchedule{..}] -> Right . Proto.make $ do
                        ProtoFields.receiver .= toProto etwsTo
                        ProtoFields.amount .= map toProto etwsAmount
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredWithSchedule .= v
            TTTransferWithScheduleAndMemo -> mkSuccess <$> do
                v <- case events of
                    [TransferredWithSchedule{..}, TransferMemo{..}] -> Right . Proto.make $ do
                        ProtoFields.receiver .= toProto etwsTo
                        ProtoFields.amount .= map toProto etwsAmount
                        ProtoFields.memo .= toProto tmMemo
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredWithSchedule .= v
            TTUpdateCredentialKeys -> mkSuccess <$> do
                v <- case events of
                    [CredentialKeysUpdated{..}] -> Right $ toProto ckuCredId
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.credentialKeysUpdated .= v
            TTUpdateCredentials -> mkSuccess <$> do
                v <- case events of
                    [CredentialsUpdated{..}] -> Right . Proto.make $ do
                        ProtoFields.newCredIds .= map toProto cuNewCredIds
                        ProtoFields.removedCredIds .= map toProto cuRemovedCredIds
                        ProtoFields.newThreshold .= toProto cuNewThreshold
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.credentialsUpdated .= v
            TTRegisterData -> mkSuccess <$> do
                v <- case events of
                    [DataRegistered{..}] -> Right $ toProto drData
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.dataRegistered .= v
            TTConfigureBaker -> mkSuccess <$> do
                let toBakerEvent = \case
                        BakerAdded{..} -> Right . Proto.make $ ProtoFields.bakerAdded .=
                          toProto ((ebaBakerId, ebaAccount, ebaSignKey, ebaElectionKey, ebaAggregationKey), ebaStake, ebaRestakeEarnings)
                        BakerRemoved{..} -> Right . Proto.make $ ProtoFields.bakerRemoved .= toProto ebrBakerId
                        BakerStakeIncreased{..} -> Right . Proto.make $ ProtoFields.bakerStakeIncreased .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsiBakerId
                            ProtoFields.newStake .= toProto ebsiNewStake)
                        BakerStakeDecreased{..} -> Right . Proto.make $ ProtoFields.bakerStakeDecreased .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsiBakerId
                            ProtoFields.newStake .= toProto ebsiNewStake)
                        BakerSetRestakeEarnings{..} -> Right . Proto.make $ ProtoFields.bakerRestakeEarningsUpdated .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsreBakerId
                            ProtoFields.restakeEarnings .= ebsreRestakeEarnings)
                        BakerKeysUpdated{..} -> Right . Proto.make $ ProtoFields.bakerKeysUpdated .= toProto (ebkuBakerId, ebkuAccount, ebkuSignKey, ebkuElectionKey, ebkuAggregationKey)
                        BakerSetOpenStatus{..} -> Right . Proto.make $ ProtoFields.bakerSetOpenStatus .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsosBakerId
                            ProtoFields.openStatus .= toProto ebsosOpenStatus)
                        BakerSetMetadataURL{..} -> Right . Proto.make $ ProtoFields.bakerSetMetadataUrl .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsmuBakerId
                            ProtoFields.url .= toProto ebsmuMetadataURL)
                        BakerSetTransactionFeeCommission{..} -> Right . Proto.make $ ProtoFields.bakerSetTransactionFeeCommission .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebstfcBakerId
                            ProtoFields.transactionFeeCommission .= toProto ebstfcTransactionFeeCommission)
                        BakerSetBakingRewardCommission{..} -> Right . Proto.make $ ProtoFields.bakerSetBakingRewardCommission .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsbrcBakerId
                            ProtoFields.bakingRewardCommission .= toProto ebsbrcBakingRewardCommission)
                        BakerSetFinalizationRewardCommission{..} -> Right . Proto.make $ ProtoFields.bakerSetFinalizationRewardCommission .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsfrcBakerId
                            ProtoFields.finalizationRewardCommission .= toProto ebsfrcFinalizationRewardCommission)
                        _ -> Left CEInvalidTransactionResult
                v <- mapM toBakerEvent events
                Right . Proto.make $ ProtoFields.bakerConfigured . ProtoFields.events .= v
            TTConfigureDelegation -> mkSuccess <$> do
                let toDelegationEvent = \case
                        DelegationStakeIncreased{..} -> Right . Proto.make $ ProtoFields.delegationStakeIncreased .= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsiDelegatorId
                            ProtoFields.newStake .= toProto edsiNewStake)
                        DelegationStakeDecreased{..} -> Right . Proto.make $ ProtoFields.delegationStakeDecreased.= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsdDelegatorId
                            ProtoFields.newStake .= toProto edsdNewStake)
                        DelegationSetRestakeEarnings{..} -> Right . Proto.make $ ProtoFields.delegationSetRestakeEarnings .= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsreDelegatorId
                            ProtoFields.restakeEarnings .= edsreRestakeEarnings)
                        DelegationSetDelegationTarget{..} -> Right . Proto.make $ ProtoFields.delegationSetDelegationTarget .= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsdtDelegatorId
                            ProtoFields.delegationTarget .= toProto edsdtDelegationTarget)
                        DelegationAdded{..} -> Right . Proto.make $ ProtoFields.delegationAdded .= toProto edaDelegatorId
                        DelegationRemoved{..} -> Right . Proto.make $ ProtoFields.delegationRemoved .= toProto edrDelegatorId
                        _ -> Left CEInvalidTransactionResult
                v <- mapM toDelegationEvent events
                Right . Proto.make $ ProtoFields.delegationConfigured . ProtoFields.events .= v
  where
    mkSuccess :: Proto.AccountTransactionEffects -> Proto.AccountTransactionDetails
    mkSuccess effects = Proto.make $ do
      ProtoFields.cost .= toProto cost
      ProtoFields.sender .= toProto sender
      ProtoFields.effects .= effects

    mkNone :: RejectReason -> Proto.AccountTransactionDetails
    mkNone rr = Proto.make $ do
      ProtoFields.cost .= toProto cost
      ProtoFields.sender .= toProto sender
      ProtoFields.effects . ProtoFields.none .=
        (Proto.make $ do
            ProtoFields.rejectReason .= toProto rr
            case ty of
              Nothing -> return ()
              Just ty' -> ProtoFields.transactionType .= toProto ty'
        )

instance ToProto Address where
  type Output Address = Proto.Address
  toProto (AddressAccount addr) = Proto.make $ ProtoFields.account .= toProto addr
  toProto (AddressContract addr) = Proto.make $ ProtoFields.contract .= toProto addr

instance ToProto Updates.UpdateType where
  type Output Updates.UpdateType = Proto.UpdateType
  toProto Updates.UpdateProtocol = Proto.UPDATE_PROTOCOL
  toProto Updates.UpdateElectionDifficulty = Proto.UPDATE_ELECTION_DIFFICULTY
  toProto Updates.UpdateEuroPerEnergy = Proto.UPDATE_EURO_PER_ENERGY
  toProto Updates.UpdateMicroGTUPerEuro = Proto.UPDATE_MICRO_GTU_PER_EURO
  toProto Updates.UpdateFoundationAccount = Proto.UPDATE_FOUNDATION_ACCOUNT
  toProto Updates.UpdateMintDistribution = Proto.UPDATE_MINT_DISTRIBUTION
  toProto Updates.UpdateTransactionFeeDistribution = Proto.UPDATE_TRANSACTION_FEE_DISTRIBUTION
  toProto Updates.UpdateGASRewards = Proto.UPDATE_GAS_REWARDS
  toProto Updates.UpdatePoolParameters = Proto.UPDATE_POOL_PARAMETERS
  toProto Updates.UpdateAddAnonymityRevoker = Proto.ADD_ANONYMITY_REVOKER
  toProto Updates.UpdateAddIdentityProvider = Proto.ADD_IDENTITY_PROVIDER
  toProto Updates.UpdateRootKeys = Proto.UPDATE_ROOT_KEYS
  toProto Updates.UpdateLevel1Keys = Proto.UPDATE_LEVEL1_KEYS
  toProto Updates.UpdateLevel2Keys = Proto.UPDATE_LEVEL2_KEYS
  toProto Updates.UpdateCooldownParameters = Proto.UPDATE_COOLDOWN_PARAMETERS
  toProto Updates.UpdateTimeParameters = Proto.UPDATE_TIME_PARAMETERS


instance ToProto TransactionType where
  type Output TransactionType = Proto.TransactionType
  toProto TTDeployModule = Proto.DEPLOY_MODULE
  toProto TTInitContract = Proto.INIT_CONTRACT
  toProto TTUpdate = Proto.UPDATE
  toProto TTTransfer = Proto.TRANSFER
  toProto TTAddBaker = Proto.ADD_BAKER
  toProto TTRemoveBaker = Proto.REMOVE_BAKER
  toProto TTUpdateBakerStake = Proto.UPDATE_BAKER_STAKE
  toProto TTUpdateBakerRestakeEarnings = Proto.UPDATE_BAKER_RESTAKE_EARNINGS
  toProto TTUpdateBakerKeys = Proto.UPDATE_BAKER_KEYS
  toProto TTUpdateCredentialKeys = Proto.UPDATE_CREDENTIAL_KEYS
  toProto TTEncryptedAmountTransfer = Proto.ENCRYPTED_AMOUNT_TRANSFER
  toProto TTTransferToEncrypted = Proto.TRANSFER_TO_ENCRYPTED
  toProto TTTransferToPublic = Proto.TRANSFER_TO_PUBLIC
  toProto TTTransferWithSchedule = Proto.TRANSFER_WITH_SCHEDULE
  toProto TTUpdateCredentials = Proto.UPDATE_CREDENTIALS
  toProto TTRegisterData = Proto.REGISTER_DATA
  toProto TTTransferWithMemo = Proto.TRANSFER_WITH_MEMO
  toProto TTEncryptedAmountTransferWithMemo = Proto.ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO
  toProto TTTransferWithScheduleAndMemo = Proto.TRANSFER_WITH_SCHEDULE_AND_MEMO
  toProto TTConfigureBaker = Proto.CONFIGURE_BAKER
  toProto TTConfigureDelegation = Proto.CONFIGURE_DELEGATION

instance ToProto Energy where
  type Output Energy = Proto.Energy
  toProto = mkWord64

instance ToProto InvokeContract.InvokeContractResult where
  type Output InvokeContract.InvokeContractResult = Either ConversionError Proto.InvokeContractResponse
  toProto InvokeContract.Failure {..} = return $ Proto.make $ ProtoFields.failure .= Proto.make (do
      ProtoFields.maybe'returnValue .= rcrReturnValue
      ProtoFields.usedEnergy .= toProto rcrUsedEnergy
      ProtoFields.reason .= toProto rcrReason)
  toProto InvokeContract.Success {..} = do
    effects <- mapM convertContractRelatedEvents rcrEvents
    return $ Proto.make $ ProtoFields.success .= Proto.make (do
      ProtoFields.maybe'returnValue .= rcrReturnValue
      ProtoFields.usedEnergy .= toProto rcrUsedEnergy
      ProtoFields.effects .= effects)

instance ToProto Slot where
  type Output Slot = Proto.Slot
  toProto = mkWord64

instance ToProto StateHash where
  type Output StateHash = Proto.StateHash
  toProto = mkSerialize

instance ToProto QueryTypes.BlockInfo where
    type Output QueryTypes.BlockInfo = Proto.BlockInfo
    toProto QueryTypes.BlockInfo{..} = Proto.make $ do
        ProtoFields.hash .= toProto biBlockHash
        ProtoFields.height .= toProto biBlockHeight
        ProtoFields.parentBlock .= toProto biBlockParent
        ProtoFields.lastFinalizedBlock .= toProto biBlockLastFinalized
        ProtoFields.genesisIndex .= toProto biGenesisIndex
        ProtoFields.eraBlockHeight .= toProto biEraBlockHeight
        ProtoFields.receiveTime .= toProto biBlockReceiveTime
        ProtoFields.arriveTime .= toProto biBlockArriveTime
        ProtoFields.slotNumber .= toProto biBlockSlot
        ProtoFields.slotTime .= toProto biBlockSlotTime
        ProtoFields.maybe'baker .= fmap toProto biBlockBaker
        ProtoFields.finalized .= biFinalized
        ProtoFields.transactionCount .= fromIntegral biTransactionCount
        ProtoFields.transactionsEnergyCost .= toProto biTransactionEnergyCost
        ProtoFields.transactionsSize .= fromIntegral biTransactionsSize
        ProtoFields.stateHash .= toProto biBlockStateHash

instance ToProto QueryTypes.PoolStatus where
    type Output QueryTypes.PoolStatus = Either Proto.PoolInfoResponse Proto.PassiveDelegationInfo
    toProto QueryTypes.BakerPoolStatus{..} = Left $ Proto.make $ do
      ProtoFields.baker .= toProto psBakerId
      ProtoFields.address .= toProto psBakerAddress
      ProtoFields.equityCapital .= toProto psBakerEquityCapital
      ProtoFields.delegatedCapital .= toProto psDelegatedCapital
      ProtoFields.delegatedCapitalCap .= toProto psDelegatedCapitalCap
      ProtoFields.poolInfo .= toProto psPoolInfo
      ProtoFields.maybe'equityPendingChange .= toProto psBakerStakePendingChange
      ProtoFields.maybe'currentPaydayInfo .= fmap toProto psCurrentPaydayStatus
      ProtoFields.allPoolTotalCapital .= toProto psAllPoolTotalCapital
    toProto QueryTypes.PassiveDelegationStatus{..} = Right $ Proto.make $ do
      ProtoFields.delegatedCapital .= toProto psDelegatedCapital
      ProtoFields.commissionRates .= toProto psCommissionRates
      ProtoFields.currentPaydayTransactionFeesEarned .= toProto psCurrentPaydayTransactionFeesEarned
      ProtoFields.currentPaydayDelegatedCapital .= toProto psCurrentPaydayDelegatedCapital
      ProtoFields.allPoolTotalCapital .= toProto psAllPoolTotalCapital

instance ToProto QueryTypes.PoolPendingChange where
    type Output QueryTypes.PoolPendingChange = Maybe Proto.PoolPendingChange
    toProto QueryTypes.PPCNoChange = Nothing
    toProto QueryTypes.PPCReduceBakerCapital {..} = Just $ Proto.make $ ProtoFields.reduce .= Proto.make (do
      ProtoFields.reducedEquityCapital .= toProto ppcBakerEquityCapital
      ProtoFields.effectiveTime .= toProto ppcEffectiveTime)
    toProto QueryTypes.PPCRemovePool {..} = Just $ Proto.make $ ProtoFields.remove .= Proto.make
      (ProtoFields.effectiveTime .= toProto ppcEffectiveTime)

instance ToProto QueryTypes.CurrentPaydayBakerPoolStatus where
    type Output QueryTypes.CurrentPaydayBakerPoolStatus = Proto.PoolCurrentPaydayInfo
    toProto QueryTypes.CurrentPaydayBakerPoolStatus {..} = Proto.make $ do
      ProtoFields.blocksBaked .= fromIntegral bpsBlocksBaked
      ProtoFields.finalizationLive .= bpsFinalizationLive
      ProtoFields.transactionFeesEarned .= toProto bpsTransactionFeesEarned
      ProtoFields.effectiveStake .= toProto bpsEffectiveStake
      ProtoFields.lotteryPower .= bpsLotteryPower
      ProtoFields.bakerEquityCapital .= toProto bpsBakerEquityCapital
      ProtoFields.delegatedCapital .= toProto bpsDelegatedCapital

instance ToProto QueryTypes.RewardStatus where
    type Output QueryTypes.RewardStatus = Proto.TokenomicsInfo
    toProto QueryTypes.RewardStatusV0 {..} = Proto.make (ProtoFields.v0 .= Proto.make (do
      ProtoFields.totalAmount .= toProto rsTotalAmount
      ProtoFields.totalEncryptedAmount .= toProto rsTotalEncryptedAmount
      ProtoFields.bakingRewardAccount .= toProto rsBakingRewardAccount
      ProtoFields.finalizationRewardAccount .= toProto rsFinalizationRewardAccount
      ProtoFields.gasAccount .= toProto rsGasAccount
      ProtoFields.protocolVersion .= toProto rsProtocolVersion))
    toProto QueryTypes.RewardStatusV1 {..} = Proto.make (ProtoFields.v1 .= Proto.make (do
      ProtoFields.totalAmount .= toProto rsTotalAmount
      ProtoFields.totalEncryptedAmount .= toProto rsTotalEncryptedAmount
      ProtoFields.bakingRewardAccount .= toProto rsBakingRewardAccount
      ProtoFields.finalizationRewardAccount .= toProto rsFinalizationRewardAccount
      ProtoFields.gasAccount .= toProto rsGasAccount
      ProtoFields.foundationTransactionRewards .= toProto rsFoundationTransactionRewards
      ProtoFields.nextPaydayTime .= toProto rsNextPaydayTime
      ProtoFields.nextPaydayMintRate .= toProto rsNextPaydayMintRate
      ProtoFields.totalStakedCapital .= toProto rsTotalStakedCapital
      ProtoFields.protocolVersion .= toProto rsProtocolVersion))

-- |NB: Assumes the data is at least 32 bytes
decodeBlockHashInput :: Word8 -> Ptr Word8 -> IO Q.BlockHashInput
decodeBlockHashInput 0 _ = return Q.BHIBest
decodeBlockHashInput 1 _ = return Q.BHILastFinal
decodeBlockHashInput _ hsh = Q.BHIGiven . coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

-- | Decode an account address from a foreign ptr. Assumes 32 bytes are available.
decodeAccountAddress :: Ptr Word8 -> IO AccountAddress
decodeAccountAddress accPtr = coerce <$> FBS.create @AccountAddressSize (\p -> copyBytes p accPtr 32)

-- |NB: Assumes the data is at least 32 bytes.
decodeTransactionHashInput :: Ptr Word8 -> IO TransactionHash
decodeTransactionHashInput hsh = coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

-- | Decode an account address from a foreign ptr.
decodeAccountIdentifierInput :: Word8 -> Ptr Word8 -> IO AccountIdentifier
decodeAccountIdentifierInput 0 dta = AccAddress <$> decodeAccountAddress dta
decodeAccountIdentifierInput 1 dta = do
    bs <- BS.unsafePackCStringLen (castPtr dta, 48)
    case S.decode bs of
        Left err -> error $ "Precondition violation in FFI call: " ++ err
        Right cid -> return (CredRegID cid)
decodeAccountIdentifierInput 2 dta = AccIndex . AccountIndex <$> peek (castPtr dta)
decodeAccountIdentifierInput n _ = error $ "Unknown account identifier tag: " ++ show n

decodeModuleRefInput :: Ptr Word8 -> IO ModuleRef
decodeModuleRefInput modRef = coerce <$> FBS.create @DigestSize (\p -> copyBytes p modRef 32)

-- |NB: Assumes the data is valid utf8.
decodeText :: Ptr Word8 -> Word32 -> IO Text
decodeText ptr len = Text.decodeUtf8 <$> BS.packCStringLen (castPtr ptr, fromIntegral len)

-- |NB: Assumes the data is valid utf8.
decodeReceiveName :: Ptr Word8 -> Word32 -> IO Wasm.ReceiveName
decodeReceiveName ptr len = Wasm.ReceiveName <$> decodeText ptr len

-- |The result type of a gRPC2 query.
data QueryResult
    = QRInternalError -- ^ An internal error occured.
    | QRSuccess -- ^ The query succeeded.
    | QRNotFound -- ^ The requested data could not be found.

-- |Convert a QueryResult to a result code.
queryResultCode :: QueryResult -> Int64
queryResultCode QRInternalError = -1
queryResultCode QRSuccess = 0
queryResultCode QRNotFound = 1

getAccountInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
    Word8 ->
    -- |Serialized identifier. Length determined by the type.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getAccountInfoV2 cptr blockType blockHashPtr accIdType accIdBytesPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    ai <- decodeAccountIdentifierInput accIdType accIdBytesPtr
    res <- runMVR (Q.getAccountInfo bhi ai) mvr
    returnMessageWithBlock (copier outVec) outHash res

copyHashTo :: Ptr Word8 -> BlockHash -> IO ()
copyHashTo dest (BlockHash (Hash h)) = FBS.withPtrReadOnly h $ \p -> copyBytes dest p 32

getAccountListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAccountListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mAddresses) <- runMVR (Q.getAccountList bhi) mvr
    case mAddresses of
        Nothing -> return (queryResultCode QRNotFound)
        Just addresses -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) addresses
            return (queryResultCode QRSuccess)

getModuleListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getModuleListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getModuleList bhi) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getModuleSourceV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Module reference.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getModuleSourceV2 cptr blockType blockHashPtr moduleRefPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    modRef <- decodeModuleRefInput moduleRefPtr
    res <- runMVR (Q.getModuleSource bhi modRef) mvr
    returnMessageWithBlock (copier outVec) outHash res

getInstanceListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getInstanceListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mInstances) <- runMVR (Q.getInstanceList bhi) mvr
    case mInstances of
        Nothing -> return (queryResultCode QRNotFound)
        Just instances -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) instances
            return (queryResultCode QRSuccess)

getInstanceInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Smart contract instance index.
    Word64 ->
    -- |Smart contract instance subindex.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getInstanceInfoV2 cptr blockType blockHashPtr addrIndex addrSubindex outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    let caddr = ContractAddress (ContractIndex addrIndex) (ContractSubindex addrSubindex)
    res <- runMVR (Q.getInstanceInfo bhi caddr) mvr
    returnMessageWithBlock (copier outVec) outHash res


getNextAccountSequenceNumberV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Serialized account address. Length is 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64
getNextAccountSequenceNumberV2 cptr accPtr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    accountAddress <- decodeAccountAddress accPtr
    res <- runMVR (Q.getNextAccountNonce accountAddress) mvr
    returnMessage (copier outVec) (Just res)

getConsensusInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64
getConsensusInfoV2 cptr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    consensusInfo <- runMVR Q.getConsensusStatus mvr
    returnMessage (copier outVec) (Just consensusInfo)

getCryptographicParametersV2 :: StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverCryptographicParameters ->
        FunPtr CopyCryptographicParametersCallback ->
        IO Int64
getCryptographicParametersV2 cptr blockType blockHashPtr outHash outPtr copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyCryptographicParametersCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeCryptographicParameters) <- runMVR (Q.getCryptographicParameters bhi) mvr
    copyHashTo outHash bh
    case maybeCryptographicParameters of
      Nothing -> return $ queryResultCode QRNotFound
      Just cryptographicParameters -> do
        withGlobalContext cryptographicParameters (copier outPtr)
        return $ queryResultCode QRSuccess

getAncestorsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Amount of ancestors (depth).
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAncestorsV2 cptr channel blockType blockHashPtr depth outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getAncestors bhi (BlockHeight depth)) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getBlockItemStatusV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Transaction hash.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockItemStatusV2 cptr trxHashPtr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    trxHash <- decodeTransactionHashInput trxHashPtr
    res <- runMVR (Q.getTransactionStatus trxHash) mvr
    case res of
        Nothing -> do
          return $ queryResultCode QRNotFound
        Just ts -> case toBlockItemStatus ts of
              Left e -> do
                let msg = case e of
                      CEFailedAccountCreation -> "An account creation failed."
                      CEInvalidAccountCreation -> "An account creation transaction occurred but was malformed and could not be converted."
                      CEFailedUpdate -> "An update transaction failed."
                      CEInvalidUpdateResult -> "An update transaction occurred but was malformed and could not be converted."
                      CEInvalidTransactionResult -> "An account transaction occurred but was malformed and could not be converted."
                mvLog mvr Logger.External Logger.LLError $ "Internal conversion error occured for transaction '" ++ show trxHash ++ "': " ++ msg
                return $ queryResultCode QRInternalError
              Right t -> do
                let encoded = Proto.encodeMessage t
                BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
                return $ queryResultCode QRSuccess

invokeContractV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- | Block ID type.
        Word8 ->
        -- | Block ID pointer.
        Ptr Word8 ->
        -- | Contract index.
        Word64 ->
        -- | Contract subindex.
        Word64 ->
        -- | Invoker address tag.
        Word8 ->
        -- | Invoker account address pointer.
        Ptr Word8 ->
        -- | Invoker contract index.
        Word64 ->
        -- | Invoker contract subindex.
        Word64 ->
        -- | Amount.
        Word64 ->
        -- | ReceiveName pointer.
        Ptr Word8 ->
        -- | ReceiveName length.
        Word32 ->
        -- | Parameter pointer.
        Ptr Word8 ->
        -- | Parameter length.
        Word32 ->
        -- | Energy
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64
invokeContractV2 cptr blockIdType blockIdPtr contractIndex contractSubindex invokerAddressType invokerAccountAddressPtr invokerContractIndex invokerContractSubindex amount receiveNamePtr receiveNameLen parameterPtr parameterLen energy outHash outVec copierCbk = do
  Ext.ConsensusRunner mvr <- deRefStablePtr cptr
  let copier = callCopyToVecCallback copierCbk
  block <- decodeBlockHashInput blockIdType blockIdPtr
  maybeInvoker <- case invokerAddressType of
        0 -> return $ Nothing
        1 -> Just . AddressAccount <$> decodeAccountAddress invokerAccountAddressPtr
        _ -> return $ Just $ AddressContract $ ContractAddress (ContractIndex invokerContractIndex) (ContractSubindex invokerContractSubindex)
  method <- decodeReceiveName receiveNamePtr receiveNameLen
  parameter <- Wasm.Parameter . BSS.toShort <$> BS.packCStringLen (castPtr parameterPtr, fromIntegral parameterLen)
  let context = InvokeContract.ContractContext {
        ccInvoker = maybeInvoker,
        ccContract = ContractAddress (ContractIndex contractIndex) (ContractSubindex contractSubindex),
        ccAmount = Amount amount,
        ccMethod = method,
        ccParameter = parameter,
        ccEnergy = Energy energy
        }
  (bh, result) <- runMVR (Q.invokeContract block context) mvr
  copyHashTo outHash bh
  case toProto <$> result of
    Nothing -> return $ queryResultCode QRNotFound
    Just (Left _) -> return $ queryResultCode QRInternalError
    Just (Right proto) -> do
      let encoded = Proto.encodeMessage proto
      BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
      return $ queryResultCode QRSuccess

getBlockInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    res <- runMVR (Q.getBlockInfo bhi) mvr
    returnMessageWithBlock (copier outVec) outHash res

getBakerListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr ChannelSendCallback ->
    IO Int64
getBakerListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mBakers) <- runMVR (Q.getRegisteredBakers bhi) mvr
    case mBakers of
        Nothing -> return (queryResultCode QRNotFound)
        Just instances -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) instances
            return (queryResultCode QRSuccess)

getPoolInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Baker id of the pool owner.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getPoolInfoV2 cptr blockType blockHashPtr bakerId outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, status) <- runMVR (Q.getPoolStatus bhi (Just $ fromIntegral bakerId)) mvr
    copyHashTo outHash bh
    case toProto <$> status of
      Just (Left proto) -> do
        let encoded = Proto.encodeMessage proto
        BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
        return $ queryResultCode QRSuccess
      _ -> return $ queryResultCode QRNotFound

getPassiveDelegationInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getPassiveDelegationInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, status) <- runMVR (Q.getPoolStatus bhi Nothing) mvr
    copyHashTo outHash bh
    case toProto <$> status of
      Just (Right proto) -> do
        let encoded = Proto.encodeMessage proto
        BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
        return $ queryResultCode QRSuccess
      _ -> return $ queryResultCode QRNotFound

getBlocksAtHeightV2 ::
  StablePtr Ext.ConsensusRunner ->
  -- | Block height, is absolute if the genesis_index is 0, otherwise relative.
  Word64 ->
  -- | Genesis index to start from. Set to 0 to use absolute height.
  Word32 ->
  -- | Whether to return results only from the specified genesis index (1),
  -- or allow results from more recent genesis indices as well (0). Out pointer
  -- for writing the block hash that was used.
  Word8 ->
  Ptr ReceiverVec ->
  -- |Callback to output data.
  FunPtr CopyToVecCallback ->
  IO Int64
getBlocksAtHeightV2 cptr height genIndex restrict outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    blocks <- runMVR (Q.getBlocksAtHeight (BlockHeight height) (GenesisIndex genIndex) (restrict /= 0)) mvr
    let proto :: Proto.BlocksAtHeightResponse = Proto.make $ ProtoFields.blocks .= fmap toProto blocks
    let encoded = Proto.encodeMessage proto
    BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
    return $ queryResultCode QRSuccess

getTokenomicsInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getTokenomicsInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    result <- runMVR (Q.getRewardStatus bhi) mvr
    returnMessageWithBlock (copier outVec) outHash result

{- |Write the hash to the provided pointer, and if the message is given encode and
   write it using the provided callback.
-}
returnMessageWithBlock ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- |Out pointer where the hash is written.
    Ptr Word8 ->
    -- |The hash of the block to which the message belongs, and potentially a
    -- message.
    (BlockHash, Maybe a) ->
    IO Int64
returnMessageWithBlock copier outHash (bh, out) = do
    copyHashTo outHash bh
    returnMessage copier out

-- |If the message is given encode and write it using the provided callback.
returnMessage ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- | The potential message.
    Maybe a ->
    IO Int64
returnMessage copier res = case res of
  Nothing -> return $ queryResultCode QRNotFound
  Just v -> do
    let encoded = Proto.encodeMessage (toProto v)
    BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier (castPtr ptr) (fromIntegral len))
    return $ queryResultCode QRSuccess

{- |Spawn a new thread that will invoke the provided callback on the list of
 encoded messages. If the callback response indicates that the channel to
 which the callback is enqueueing is full, the thread will wait. The wait time
 follows exponential backoff strategy to a maximum of 10 seconds.
-}
enqueueMessages :: (Proto.Message (Output a), ToProto a) => (Ptr Word8 -> Int64 -> IO Int32) -> [a] -> IO ThreadId
enqueueMessages callback = forkIO . go 0 . map encodeMsg
  where
    encodeMsg = Proto.encodeMessage . toProto
    go _ [] = () <$ callback nullPtr maxBound -- close the sender channel.
    go n msgs@(msg : msgs') =
        BS.unsafeUseAsCStringLen msg $ \(headPtr, len) -> do
            res <- callback (castPtr headPtr) (fromIntegral len)
            if res == 0
                then go 0 msgs' -- reset wait time to 10ms.
                else
                    if res == -1
                        then do
                            let delay = (2 ^ n) * 10_000
                            threadDelay delay
                            go (min (n + 1) (10 :: Int)) msgs -- maximum delay is 10 seconds
                        else return () -- the sender channel is now dropped, so we stop.

-- * Foreign exports

foreign export ccall
    getAccountInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
        Word8 ->
        -- |Serialized identifier. Length determined by the type.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getAccountListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleSourceV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Module reference.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getInstanceListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getAncestorsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Amount of ancestors (depth).
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getInstanceInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Smart contract address index.
        Word64 ->
        -- |Smart contract address subindex.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getNextAccountSequenceNumberV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Serialized account address. Length must be 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getBlockItemStatusV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |TransactionHash. Length must be 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getConsensusInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    invokeContractV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- | Block ID type.
        Word8 ->
        -- | Block ID pointer.
        Ptr Word8 ->
        -- | Contract index.
        Word64 ->
        -- | Contract subindex.
        Word64 ->
        -- | Invoker address tag.
        Word8 ->
        -- | Invoker account address pointer.
        Ptr Word8 ->
        -- | Invoker contract index.
        Word64 ->
        -- | Invoker contract subindex.
        Word64 ->
        -- | Amount.
        Word64 ->
        -- | ReceiveName pointer.
        Ptr Word8 ->
        -- | ReceiveName length.
        Word32 ->
        -- | Parameter pointer.
        Ptr Word8 ->
        -- | Parameter length.
        Word32 ->
        -- | Energy
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getCryptographicParametersV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverCryptographicParameters ->
        FunPtr CopyCryptographicParametersCallback ->
        IO Int64

foreign export ccall
    getBlockInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getBakerListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr ChannelSendCallback ->
        IO Int64

foreign export ccall
    getPoolInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- | Baker id of the pool owner.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getPassiveDelegationInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getBlocksAtHeightV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- | Block height, is absolute if the genesis_index is 0, otherwise relative.
        Word64 ->
        -- | Genesis index to start from. Set to 0 to use absolute height.
        Word32 ->
        -- | Whether to return results only from the specified genesis index (1),
        -- or allow results from more recent genesis indices as well (0). Out pointer
        -- for writing the block hash that was used.
        Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64

foreign export ccall
    getTokenomicsInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64
