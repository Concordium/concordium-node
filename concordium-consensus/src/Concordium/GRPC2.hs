{-# LANGUAGE DataKinds #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

{- |Part of the implementation of the GRPC2 interface. This module constructs
    responses to queries that are handled by the Haskell part of the code.

   This module only provides foreign exports, and should not be imported from
   other Haskell code.
-}
module Concordium.GRPC2 () where

import Control.Concurrent
import qualified Data.ByteString as BS
import qualified Data.ByteString.Unsafe as BS
import Data.Coerce
import qualified Data.FixedByteString as FBS
import Data.Int
import qualified Data.Map.Strict as Map
import qualified Data.ProtoLens as Proto
import qualified Data.ProtoLens.Combinators as Proto
import qualified Data.ProtoLens.Field
import qualified Data.Serialize as S
import qualified Data.Set as Set
import Data.Word
import Foreign
import Lens.Micro.Platform
import qualified Proto.Concordium.Types as Proto
import qualified Proto.Concordium.Types_Fields as ProtoFields

import Concordium.Crypto.EncryptedTransfers
import Concordium.ID.Types
import Concordium.Types
import Concordium.Types.Accounts
import qualified Concordium.Types.Queries as QueryTypes

import qualified Concordium.External as Ext -- TODO: This is not an ideal configuration.
import Concordium.MultiVersion (
    MVR (..),
 )
import qualified Concordium.Queries as Q

import Concordium.ID.Parameters (withGlobalContext)
import Concordium.Common.Time
import Concordium.Common.Version
import Concordium.Crypto.SHA256 (DigestSize, Hash (Hash))
import Concordium.Crypto.SignatureScheme (VerifyKey (..))
import Concordium.Types.Accounts.Releases
import Concordium.Types.Execution
import qualified Concordium.Wasm as Wasm
import Data.Text (Text)
import Data.Time (UTCTime)
import Concordium.Types.Block (AbsoluteBlockHeight(..))
import Concordium.GlobalState.Parameters (CryptographicParameters)

{- |An opaque representation of a Rust vector. This is used by callbacks to copy
 the message generated by a query to Rust, so it can be forwarded back to the
 caller.
-}
data ReceiverVec

{- |An opaque representation of Rust cryptographic parameters. This is used by callbacks to copy
 cryptographic parameters to Rust, so it can be forwarded back to the caller.
-}
data ReceiverCryptographicParameters

-- |A type of callback that extends the given vector with the provided data.
type CopyToVecCallback = Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()

-- |A type of callback that extends the given vector with the provided data.
type CopyCryptographicParametersCallback = Ptr ReceiverCryptographicParameters -> Ptr CryptographicParameters -> IO ()

{- |An opaque representation of a channel to which streaming responses can write
 data. When a request is made to an endpoint with a streaming response then a
 channel is created in Rust code. One endpoint is passed to Haskell and the
 other end (the receiver) is kept by the request handler. Haskell code is
 meant to spawn a background thread that streams data into the channel, using
 the provided 'ChannelSendCallback' to write each item into the channel.
-}
data SenderChannel

{- |The type of callbacks to enqueue the given data in the channel. The response
 code of 0 means data was successfully enqueued, 1 means that the channel is
 now full, so data was not enqueued. The sender should try again. Response of
 2 means the channel is dead. In this case the provided 'SenderChannel' is
 dropped, and the callback must not be invoked again.
-}
type ChannelSendCallback = Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callChannelSendCallback :: FunPtr ChannelSendCallback -> ChannelSendCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyToVecCallback :: FunPtr CopyToVecCallback -> CopyToVecCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyCryptographicParametersCallback :: FunPtr CopyCryptographicParametersCallback -> CopyCryptographicParametersCallback

-- |A helper function that can be used to construct a value of a protobuf
-- "wrapper" type by serializing the provided value @a@ using its serialize
-- instance.
--
-- More concretely, the wrapper type should be of the form
--
-- > message Wrapper {
-- >    bytes value = 1
-- > }
--
-- where the name @Wrapper@ can be arbitrary, but the @value@ field must exist,
-- and it must have type @bytes@.
mkSerialize ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        BS.ByteString
    , S.Serialize a
    ) =>
    a ->
    b
mkSerialize ek = Proto.make (ProtoFields.value .= S.encode ek)

-- |Like 'mkSerialize' above, but used to set a wrapper type whose @value@ field
-- has type @uint64@. The supplied value must be coercible to a 'Word64'.
-- Coercible here means that the value is a newtype wrapper (possibly repeated)
-- of a Word64.
mkWord64 ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word64
    , Coercible a Word64
    ) =>
    a ->
    b
mkWord64 a = Proto.make (ProtoFields.value .= coerce a)

-- |Like 'mkWord64', but for 32-bit integers instead of 64.
mkWord32 ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word32
    , Coercible a Word32
    ) =>
    a ->
    b
mkWord32 a = Proto.make (ProtoFields.value .= coerce a)

-- |Like 'mkWord32', but the supplied value must be coercible to
-- 'Word8'.
mkWord8 ::
    forall a b.
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word32
    , Coercible a Word8
    ) =>
    a ->
    b
mkWord8 a = Proto.make (ProtoFields.value .= (fromIntegral (coerce a :: Word8) :: Word32))

-- |A helper class analogous to something like Aeson's ToJSON.
-- It exists to make it more manageable to convert the internal Haskell types to
-- their Protobuf equivalents.
class ToProto a where
    -- |The corresponding Proto type.
    type Output a
    -- |A conversion function from the type to its protobuf equivalent.
    toProto :: a -> Output a

instance ToProto Amount where
    type Output Amount = Proto.Amount
    toProto = mkWord64

instance ToProto BlockHash where
    type Output BlockHash = Proto.BlockHash
    toProto = mkSerialize

instance ToProto TransactionHashV0 where
    type Output TransactionHashV0 = Proto.TransactionHash
    toProto = mkSerialize

instance ToProto ModuleRef where
    type Output ModuleRef = Proto.ModuleRef
    toProto = mkSerialize

instance ToProto Wasm.WasmModule where
    type Output Wasm.WasmModule = Proto.VersionedModuleSource
    toProto (Wasm.WasmModuleV0 modul) = Proto.make (ProtoFields.v0 .=
       Proto.make (ProtoFields.value .= Wasm.moduleSource (Wasm.wmvSource modul)))
    toProto (Wasm.WasmModuleV1 modul) = Proto.make (ProtoFields.v1 .=
       Proto.make ( ProtoFields.value .= Wasm.moduleSource (Wasm.wmvSource modul)))

instance ToProto Wasm.InstanceInfo where
    type Output Wasm.InstanceInfo = Proto.InstanceInfo
    toProto Wasm.InstanceInfoV0{..} = Proto.make ( ProtoFields.v0 .= Proto.make ( do
      ProtoFields.owner .= mkSerialize iiOwner
      ProtoFields.amount .= mkWord64 iiAmount
      ProtoFields.methods .= (toProto <$> Set.toList iiMethods)
      ProtoFields.name .= toProto iiName
      ProtoFields.sourceModule .= toProto iiSourceModule
      ProtoFields.model .= toProto iiModel))
    toProto Wasm.InstanceInfoV1{..} = Proto.make ( ProtoFields.v1 .= Proto.make ( do
      ProtoFields.owner .= mkSerialize iiOwner
      ProtoFields.amount .= mkWord64 iiAmount
      ProtoFields.methods .= (toProto <$> Set.toList iiMethods)
      ProtoFields.name .= toProto iiName
      ProtoFields.sourceModule .= toProto iiSourceModule))

instance ToProto Wasm.ReceiveName where
  type Output Wasm.ReceiveName = Proto.ReceiveName
  toProto name = Proto.make $ ProtoFields.value .= Wasm.receiveName name

instance ToProto Wasm.InitName where
  type Output Wasm.InitName = Proto.InitName
  toProto name = Proto.make $ ProtoFields.value .= Wasm.initName name

instance ToProto Wasm.ContractState where
  type Output Wasm.ContractState = Proto.ContractStateV0
  toProto = mkSerialize

instance ToProto ContractAddress where
  type Output ContractAddress = Proto.ContractAddress
  toProto ContractAddress{..} = Proto.make $ do
    ProtoFields.index .= _contractIndex contractIndex
    ProtoFields.subindex .= _contractSubindex contractSubindex

instance ToProto BlockHeight where
    type Output BlockHeight = Proto.BlockHeight
    toProto = mkWord64

instance ToProto AbsoluteBlockHeight where
    type Output AbsoluteBlockHeight = Proto.AbsoluteBlockHeight
    toProto = mkWord64

instance ToProto AccountAddress where
    type Output AccountAddress = Proto.AccountAddress
    toProto = mkSerialize

instance ToProto Nonce where
    type Output Nonce = Proto.SequenceNumber
    toProto = mkWord64

instance ToProto UTCTime where
    type Output UTCTime = Proto.Timestamp
    toProto time = mkWord64 $ utcTimeToTimestamp time

instance ToProto Duration where
    type Output Duration = Proto.Duration
    toProto = mkWord64

instance ToProto GenesisIndex where
    type Output GenesisIndex = Proto.GenesisIndex
    toProto = mkWord32

instance ToProto ProtocolVersion where
    type Output ProtocolVersion = Proto.ProtocolVersion
    toProto P1 = Proto.PROTOCOL_VERSION_1
    toProto P2 = Proto.PROTOCOL_VERSION_2
    toProto P3 = Proto.PROTOCOL_VERSION_3
    toProto P4 = Proto.PROTOCOL_VERSION_4

instance ToProto QueryTypes.NextAccountNonce where
    type Output QueryTypes.NextAccountNonce = Proto.NextAccountSequenceNumber
    toProto QueryTypes.NextAccountNonce{..} = Proto.make $ do
      ProtoFields.sequenceNumber .= toProto nanNonce
      ProtoFields.allFinal .= nanAllFinal

instance ToProto QueryTypes.ConsensusStatus where
    type Output QueryTypes.ConsensusStatus = Proto.ConsensusInfo
    toProto QueryTypes.ConsensusStatus{..} = Proto.make $ do
      ProtoFields.bestBlock .= toProto csBestBlock
      ProtoFields.genesisBlock .= toProto csGenesisBlock
      ProtoFields.genesisTime .= toProto csGenesisTime
      ProtoFields.slotDuration .= toProto csSlotDuration
      ProtoFields.epochDuration .= toProto csEpochDuration
      ProtoFields.lastFinalizedBlock .= toProto csLastFinalizedBlock
      ProtoFields.bestBlockHeight .= toProto csBestBlockHeight
      ProtoFields.lastFinalizedBlockHeight .= toProto csLastFinalizedBlockHeight
      ProtoFields.blocksReceivedCount .= fromIntegral csBlocksReceivedCount
      ProtoFields.maybe'blockLastReceivedTime .= fmap toProto csBlockLastReceivedTime
      ProtoFields.blockReceiveLatencyEma .= csBlockReceiveLatencyEMA
      ProtoFields.blockReceiveLatencyEmsd .= csBlockReceiveLatencyEMSD
      ProtoFields.maybe'blockReceivePeriodEma .= csBlockReceivePeriodEMA
      ProtoFields.maybe'blockReceivePeriodEmsd .= csBlockReceivePeriodEMSD
      ProtoFields.blocksVerifiedCount .= fromIntegral csBlocksVerifiedCount
      ProtoFields.maybe'blockLastArrivedTime .= fmap toProto csBlockLastArrivedTime
      ProtoFields.blockArriveLatencyEma .= csBlockArriveLatencyEMA
      ProtoFields.blockArriveLatencyEmsd .= csBlockArriveLatencyEMSD
      ProtoFields.maybe'blockArrivePeriodEma .= csBlockArrivePeriodEMA
      ProtoFields.maybe'blockArrivePeriodEmsd .= csBlockArrivePeriodEMSD
      ProtoFields.transactionsPerBlockEma .= csTransactionsPerBlockEMA
      ProtoFields.transactionsPerBlockEmsd .= csTransactionsPerBlockEMSD
      ProtoFields.finalizationCount .= fromIntegral csFinalizationCount
      ProtoFields.maybe'lastFinalizedTime .= fmap toProto csLastFinalizedTime
      ProtoFields.maybe'finalizationPeriodEma .= csFinalizationPeriodEMA
      ProtoFields.maybe'finalizationPeriodEmsd .= csFinalizationPeriodEMSD
      ProtoFields.protocolVersion .= toProto csProtocolVersion
      ProtoFields.genesisIndex .= toProto csGenesisIndex
      ProtoFields.currentEraGenesisBlock .= toProto csCurrentEraGenesisBlock
      ProtoFields.currentEraGenesisTime .= toProto csCurrentEraGenesisTime

instance ToProto AccountThreshold where
    type Output AccountThreshold = Proto.AccountThreshold
    toProto = mkWord8

instance ToProto SignatureThreshold where
    type Output SignatureThreshold = Proto.SignatureThreshold
    toProto = mkWord8

instance ToProto Threshold where
    type Output Threshold = Proto.ArThreshold
    toProto = mkWord8

instance ToProto AccountIndex where
    type Output AccountIndex = Proto.AccountIndex
    toProto = mkWord64

instance ToProto BakerId where
    type Output BakerId = Proto.BakerId
    toProto = mkWord64

instance ToProto EncryptedAmount where
    type Output EncryptedAmount = Proto.EncryptedAmount
    toProto = mkSerialize

instance ToProto AccountEncryptedAmount where
    type Output AccountEncryptedAmount = Proto.EncryptedBalance
    toProto encBal =
        case _aggregatedAmount encBal of
            Nothing -> Proto.make mkEncryptedBalance
            Just (aggAmount, numAgg) -> Proto.make $ do
                mkEncryptedBalance
                ProtoFields.aggregatedAmount .= toProto aggAmount
                ProtoFields.numAggregated .= numAgg
      where
        mkEncryptedBalance = do
            ProtoFields.selfAmount .= toProto (_selfAmount encBal)
            ProtoFields.startIndex .= coerce (_startIndex encBal)

instance ToProto AccountReleaseSummary where
    type Output AccountReleaseSummary = Proto.ReleaseSchedule
    toProto ars = Proto.make $ do
        ProtoFields.total .= toProto (releaseTotal ars)
        ProtoFields.schedules .= (toProto <$> releaseSchedule ars)

instance ToProto ScheduledRelease where
    type Output ScheduledRelease = Proto.Release
    toProto r = Proto.make $ do
        ProtoFields.timestamp .= mkWord64 (releaseTimestamp r)
        ProtoFields.amount .= toProto (releaseAmount r)
        ProtoFields.transactions .= (toProto <$> releaseTransactions r)

instance ToProto (StakePendingChange' UTCTime) where
    type Output (StakePendingChange' UTCTime) = Maybe Proto.StakePendingChange
    toProto NoChange = Nothing
    toProto (ReduceStake newStake effectiveTime) =
        Just . Proto.make $
            ( ProtoFields.reduce
                .= Proto.make
                    ( do
                        ProtoFields.newStake .= toProto newStake
                        ProtoFields.effectiveTime .= mkWord64 (utcTimeToTimestamp effectiveTime)
                    )
            )
    toProto (RemoveStake effectiveTime) =
        Just . Proto.make $ (ProtoFields.remove .= mkWord64 (utcTimeToTimestamp effectiveTime))

instance ToProto BakerInfo where
    type Output BakerInfo = Proto.BakerInfo
    toProto BakerInfo{..} =
        Proto.make
            ( do
                ProtoFields.bakerId .= mkWord64 _bakerIdentity
                ProtoFields.electionKey .= mkSerialize _bakerElectionVerifyKey
                ProtoFields.signatureKey .= mkSerialize _bakerSignatureVerifyKey
                ProtoFields.aggregationKey .= mkSerialize _bakerAggregationVerifyKey
            )

instance ToProto OpenStatus where
    type Output OpenStatus = Proto.OpenStatus
    toProto OpenForAll = Proto.OPEN_STATUS_OPEN_FOR_ALL
    toProto ClosedForNew = Proto.OPEN_STATUS_CLOSED_FOR_NEW
    toProto ClosedForAll = Proto.OPEN_STATUS_CLOSED_FOR_ALL

instance ToProto UrlText where
    type Output UrlText = Text
    toProto (UrlText s) = s

instance ToProto AmountFraction where
    type Output AmountFraction = Proto.AmountFraction
    toProto (AmountFraction ppht) = Proto.make (ProtoFields.partsPerHundredThousand .= fromIntegral ppht)

instance ToProto CommissionRates where
    type Output CommissionRates = Proto.CommissionRates
    toProto CommissionRates{..} = Proto.make $ do
        ProtoFields.finalization .= toProto _finalizationCommission
        ProtoFields.baking .= toProto _bakingCommission
        ProtoFields.transaction .= toProto _transactionCommission

instance ToProto BakerPoolInfo where
    type Output BakerPoolInfo = Proto.BakerPoolInfo
    toProto BakerPoolInfo{..} = Proto.make $ do
        ProtoFields.openStatus .= toProto _poolOpenStatus
        ProtoFields.url .= toProto _poolMetadataUrl
        ProtoFields.commissionRates .= toProto _poolCommissionRates

instance ToProto AccountStakingInfo where
    type Output AccountStakingInfo = Maybe Proto.AccountStakingInfo
    toProto AccountStakingNone = Nothing
    toProto AccountStakingBaker{..} =
        Just . Proto.make $
            ( do
                ProtoFields.baker
                    .= Proto.make
                        ( do
                            ProtoFields.stakedAmount .= toProto asiStakedAmount
                            ProtoFields.restakeEarnings .= asiStakeEarnings
                            ProtoFields.bakerInfo .= toProto asiBakerInfo
                            ProtoFields.maybe'pendingChange .= toProto asiPendingChange
                            case asiPoolInfo of
                                Nothing -> return ()
                                Just asipi -> ProtoFields.poolInfo .= toProto asipi
                        )
            )
    toProto AccountStakingDelegated{..} =
        Just . Proto.make $
            ( do
                ProtoFields.delegator
                    .= Proto.make
                        ( do
                            ProtoFields.stakedAmount .= mkWord64 asiStakedAmount
                            ProtoFields.restakeEarnings .= asiStakeEarnings
                            ProtoFields.target
                                .= Proto.make
                                    ( do
                                        case asiDelegationTarget of
                                            DelegatePassive -> ProtoFields.passive .= Proto.defMessage
                                            DelegateToBaker bi -> ProtoFields.baker .= mkWord64 bi
                                    )
                            ProtoFields.maybe'pendingChange .= toProto asiDelegationPendingChange
                        )
            )

instance ToProto (Map.Map CredentialIndex (Versioned RawAccountCredential)) where
    type Output (Map.Map CredentialIndex (Versioned RawAccountCredential)) = Map.Map Word32 Proto.AccountCredential
    toProto = Map.fromAscList . map (\(k, v) -> (fromIntegral k, toProto (vValue v))) . Map.toAscList

instance ToProto CredentialPublicKeys where
    type Output CredentialPublicKeys = Proto.CredentialPublicKeys
    toProto CredentialPublicKeys{..} = Proto.make $ do
        ProtoFields.threshold .= mkWord8 credThreshold
        ProtoFields.keys .= (Map.fromAscList . map convertKey . Map.toAscList $ credKeys)
      where
        convertKey (ki, VerifyKeyEd25519 key) = (fromIntegral ki, Proto.make $ ProtoFields.ed25519Key .= S.encode key)

instance ToProto Policy where
    type Output Policy = Proto.Policy
    toProto Policy{..} = Proto.make $ do
        ProtoFields.createdAt .= toProto pCreatedAt
        ProtoFields.validTo .= toProto pValidTo
        ProtoFields.attributes .= mkAttributes pItems
      where
        mkAttributes =
            Map.fromAscList
                . map (\(AttributeTag tag, value) -> (fromIntegral tag, S.runPut (S.putShortByteString (coerce value))))
                . Map.toAscList

instance ToProto YearMonth where
    type Output YearMonth = Proto.YearMonth
    toProto YearMonth{..} = Proto.make $ do
        ProtoFields.year .= fromIntegral ymYear
        ProtoFields.month .= fromIntegral ymMonth

instance ToProto RawCredentialRegistrationID where
    type Output RawCredentialRegistrationID = Proto.CredentialRegistrationId
    toProto = mkSerialize

instance ToProto IdentityProviderIdentity where
    type Output IdentityProviderIdentity = Proto.IdentityProviderIdentity
    toProto = mkWord32

instance ToProto Commitment where
    type Output Commitment = Proto.Commitment
    toProto = mkSerialize

instance ToProto CredentialDeploymentCommitments where
    type Output CredentialDeploymentCommitments = Proto.CredentialCommitments
    toProto CredentialDeploymentCommitments{..} = Proto.make $ do
        ProtoFields.prf .= toProto cmmPrf
        ProtoFields.credCounter .= toProto cmmCredCounter
        ProtoFields.maxAccounts .= toProto cmmMaxAccounts
        ProtoFields.attributes
            .= ( Map.fromAscList
                    . map (\(AttributeTag tag, v) -> (fromIntegral tag :: Word32, toProto v))
                    . Map.toAscList
               )
                cmmAttributes
        ProtoFields.idCredSecSharingCoeff .= map toProto cmmIdCredSecSharingCoeff

instance ToProto RawAccountCredential where
    type Output RawAccountCredential = Proto.AccountCredential
    toProto (InitialAC InitialCredentialDeploymentValues{..}) =
        Proto.make $
            ProtoFields.initial
                .= Proto.make
                    ( do
                        ProtoFields.keys .= toProto icdvAccount
                        ProtoFields.credId .= toProto icdvRegId
                        ProtoFields.ipId .= toProto icdvIpId
                        ProtoFields.policy .= toProto icdvPolicy
                    )
    toProto (NormalAC CredentialDeploymentValues{..} commitments) =
        Proto.make $
            ProtoFields.normal
                .= Proto.make
                    ( do
                        ProtoFields.keys .= toProto cdvPublicKeys
                        ProtoFields.credId .= toProto cdvCredId
                        ProtoFields.ipId .= toProto cdvIpId
                        ProtoFields.policy .= toProto cdvPolicy
                        ProtoFields.arThreshold .= toProto cdvThreshold
                        ProtoFields.commitments .= toProto commitments
                    )

instance ToProto AccountEncryptionKey where
    type Output AccountEncryptionKey = Proto.EncryptionKey
    toProto = mkSerialize

instance ToProto AccountInfo where
    type Output AccountInfo = Proto.AccountInfo
    toProto AccountInfo{..} = Proto.make $ do
        ProtoFields.sequenceNumber .= toProto aiAccountNonce
        ProtoFields.amount .= toProto aiAccountAmount
        ProtoFields.schedule .= toProto aiAccountReleaseSchedule
        ProtoFields.creds .= toProto aiAccountCredentials
        ProtoFields.threshold .= toProto aiAccountThreshold
        ProtoFields.encryptedBalance .= toProto aiAccountEncryptedAmount
        ProtoFields.encryptionKey .= toProto aiAccountEncryptionKey
        ProtoFields.index .= toProto aiAccountIndex
        ProtoFields.address .= toProto aiAccountAddress
        ProtoFields.maybe'stake .= toProto aiStakingInfo

instance ToProto Address where
  type Output Address = Proto.Address
  toProto (AddressAccount addr) = Proto.make $ ProtoFields.account .= toProto addr
  toProto (AddressContract addr) = Proto.make $ ProtoFields.contract .= toProto addr

instance ToProto Energy where
  type Output Energy = Proto.Energy
  toProto = mkWord64

instance ToProto Slot where
  type Output Slot = Proto.Slot
  toProto = mkWord64

instance ToProto StateHash where
  type Output StateHash = Proto.StateHash
  toProto = mkSerialize

instance ToProto QueryTypes.BlockInfo where
    type Output QueryTypes.BlockInfo = Proto.BlockInfo
    toProto QueryTypes.BlockInfo{..} = Proto.make $ do
        ProtoFields.hash .= toProto biBlockHash
        ProtoFields.height .= toProto biBlockHeight
        ProtoFields.parentBlock .= toProto biBlockParent
        ProtoFields.lastFinalizedBlock .= toProto biBlockLastFinalized
        ProtoFields.genesisIndex .= toProto biGenesisIndex
        ProtoFields.eraBlockHeight .= toProto biEraBlockHeight
        ProtoFields.receiveTime .= toProto biBlockReceiveTime
        ProtoFields.arriveTime .= toProto biBlockArriveTime
        ProtoFields.slotNumber .= toProto biBlockSlot
        ProtoFields.slotTime .= toProto biBlockSlotTime
        ProtoFields.maybe'baker .= fmap toProto biBlockBaker
        ProtoFields.finalized .= biFinalized
        ProtoFields.transactionCount .= fromIntegral biTransactionCount
        ProtoFields.transactionsEnergyCost .= toProto biTransactionEnergyCost
        ProtoFields.transactionsSize .= fromIntegral biTransactionsSize
        ProtoFields.stateHash .= toProto biBlockStateHash

-- |NB: Assumes the data is at least 32 bytes
decodeBlockHashInput :: Word8 -> Ptr Word8 -> IO Q.BlockHashInput
decodeBlockHashInput 0 _ = return Q.BHIBest
decodeBlockHashInput 1 _ = return Q.BHILastFinal
decodeBlockHashInput _ hsh = Q.BHIGiven . coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

-- | Decode an account address from a foreign ptr. Assumes 32 bytes are available.
decodeAccountAddress :: Ptr Word8 -> IO AccountAddress
decodeAccountAddress accPtr = coerce <$> FBS.create @AccountAddressSize (\p -> copyBytes p accPtr 32)

-- | Decode an account address from a foreign ptr.
decodeAccountIdentifierInput :: Word8 -> Ptr Word8 -> IO AccountIdentifier
decodeAccountIdentifierInput 0 dta = AccAddress <$> decodeAccountAddress dta
decodeAccountIdentifierInput 1 dta = do
    bs <- BS.unsafePackCStringLen (castPtr dta, 48)
    case S.decode bs of
        Left err -> error $ "Precondition violation in FFI call: " ++ err
        Right cid -> return (CredRegID cid)
decodeAccountIdentifierInput 2 dta = AccIndex . AccountIndex <$> peek (castPtr dta)
decodeAccountIdentifierInput n _ = error $ "Unknown account identifier tag: " ++ show n

decodeModuleRefInput :: Ptr Word8 -> IO ModuleRef
decodeModuleRefInput modRef = coerce <$> FBS.create @DigestSize (\p -> copyBytes p modRef 32)

data QueryResult
    = QRSuccess
    | QRNotFound

queryResultCode :: QueryResult -> Int64
queryResultCode QRSuccess = 0
queryResultCode QRNotFound = 1

getAccountInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
    Word8 ->
    -- |Serialized identifier. Length determined by the type.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getAccountInfoV2 cptr blockType blockHashPtr accIdType accIdBytesPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    ai <- decodeAccountIdentifierInput accIdType accIdBytesPtr
    res <- runMVR (Q.getAccountInfo bhi ai) mvr
    returnMessageWithBlock (copier outVec) outHash res

copyHashTo :: Ptr Word8 -> BlockHash -> IO ()
copyHashTo dest (BlockHash (Hash h)) = FBS.withPtrReadOnly h $ \p -> copyBytes dest p 32

getAccountListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAccountListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mAddresses) <- runMVR (Q.getAccountList bhi) mvr
    case mAddresses of
        Nothing -> return (queryResultCode QRNotFound)
        Just addresses -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) addresses
            return (queryResultCode QRSuccess)

getModuleListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getModuleListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getModuleList bhi) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getModuleSourceV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Module reference.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getModuleSourceV2 cptr blockType blockHashPtr moduleRefPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    modRef <- decodeModuleRefInput moduleRefPtr
    res <- runMVR (Q.getModuleSource bhi modRef) mvr
    returnMessageWithBlock (copier outVec) outHash res

getInstanceListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getInstanceListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mInstances) <- runMVR (Q.getInstanceList bhi) mvr
    case mInstances of
        Nothing -> return (queryResultCode QRNotFound)
        Just instances -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) instances
            return (queryResultCode QRSuccess)

getInstanceInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Smart contract instance index.
    Word64 ->
    -- |Smart contract instance subindex.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getInstanceInfoV2 cptr blockType blockHashPtr addrIndex addrSubindex outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    let caddr = ContractAddress (ContractIndex addrIndex) (ContractSubindex addrSubindex)
    res <- runMVR (Q.getInstanceInfo bhi caddr) mvr
    returnMessageWithBlock (copier outVec) outHash res


getNextAccountSequenceNumberV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Serialized account address. Length is 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64
getNextAccountSequenceNumberV2 cptr accPtr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    accountAddress <- decodeAccountAddress accPtr
    res <- runMVR (Q.getNextAccountNonce accountAddress) mvr
    returnMessage (copier outVec) (Just res)

getConsensusInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64
getConsensusInfoV2 cptr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    consensusInfo <- runMVR Q.getConsensusStatus mvr
    returnMessage (copier outVec) (Just consensusInfo)

getCryptographicParametersV2 :: StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverCryptographicParameters ->
        FunPtr CopyCryptographicParametersCallback ->
        IO Int64
getCryptographicParametersV2 cptr blockType blockHashPtr outHash outPtr copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyCryptographicParametersCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, maybeCryptographicParameters) <- runMVR (Q.getCryptographicParameters bhi) mvr
    copyHashTo outHash bh
    case maybeCryptographicParameters of
      Nothing -> return $ queryResultCode QRNotFound
      Just cryptographicParameters -> do
        withGlobalContext cryptographicParameters (copier outPtr)
        return $ queryResultCode QRSuccess

getAncestorsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Amount of ancestors (depth).
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAncestorsV2 cptr channel blockType blockHashPtr depth outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getAncestors bhi (BlockHeight depth)) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getBlockInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getBlockInfoV2 cptr blockType blockHashPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    res <- runMVR (Q.getBlockInfo bhi) mvr
    returnMessageWithBlock (copier outVec) outHash res

{- |Write the hash to the provided pointer, and if the message is given encode and
   write it using the provided callback.
-}
returnMessageWithBlock ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- |Out pointer where the hash is written.
    Ptr Word8 ->
    -- |The hash of the block to which the message belongs, and potentially a
    -- message.
    (BlockHash, Maybe a) ->
    IO Int64
returnMessageWithBlock copier outHash (bh, out) = do
    copyHashTo outHash bh
    returnMessage copier out

-- |If the message is given encode and write it using the provided callback.
returnMessage ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- | The potential message.
    Maybe a ->
    IO Int64
returnMessage copier res = case res of
  Nothing -> return $ queryResultCode QRNotFound
  Just v -> do
    let encoded = Proto.encodeMessage (toProto v)
    BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier (castPtr ptr) (fromIntegral len))
    return $ queryResultCode QRSuccess

{- |Spawn a new thread that will invoke the provided callback on the list of
 encoded messages. If the callback response indicates that the channel to
 which the callback is enqueueing is full, the thread will wait. The wait time
 follows exponential backoff strategy to a maximum of 10 seconds.
-}
enqueueMessages :: (Proto.Message (Output a), ToProto a) => (Ptr Word8 -> Int64 -> IO Int32) -> [a] -> IO ThreadId
enqueueMessages callback = forkIO . go 0 . map encodeMsg
  where
    encodeMsg = Proto.encodeMessage . toProto
    go _ [] = () <$ callback nullPtr maxBound -- close the sender channel.
    go n msgs@(msg : msgs') =
        BS.unsafeUseAsCStringLen msg $ \(headPtr, len) -> do
            res <- callback (castPtr headPtr) (fromIntegral len)
            if res == 0
                then go 0 msgs' -- reset wait time to 10ms.
                else
                    if res == -1
                        then do
                            let delay = (2 ^ n) * 10_000
                            threadDelay delay
                            go (min (n + 1) (10 :: Int)) msgs -- maximum delay is 10 seconds
                        else return () -- the sender channel is now dropped, so we stop.

-- * Foreign exports

foreign export ccall
    getAccountInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
        Word8 ->
        -- |Serialized identifier. Length determined by the type.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getAccountListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleSourceV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Module reference.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getInstanceListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getAncestorsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Amount of ancestors (depth).
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getInstanceInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Smart contract address index.
        Word64 ->
        -- |Smart contract address subindex.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getNextAccountSequenceNumberV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Serialized account address. Length must be 32 bytes.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getConsensusInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getCryptographicParametersV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverCryptographicParameters ->
        FunPtr CopyCryptographicParametersCallback ->
        IO Int64

foreign export ccall
    getBlockInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr CopyToVecCallback ->
        IO Int64
