{-# LANGUAGE DataKinds #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

{- |Part of the implementation of the GRPC2 interface. This module constructs
    responses to queries that are handled by the Haskell part of the code.

   This module only provides foreign exports, and should not be imported from
   other Haskell code.
-}
module Concordium.GRPC2 () where

import Control.Concurrent
import qualified Data.ByteString as BS
import qualified Data.ByteString.Unsafe as BS
import Data.Coerce
import qualified Data.FixedByteString as FBS
import Data.Int
import qualified Data.Map.Strict as Map
import qualified Data.ProtoLens as Proto
import qualified Data.ProtoLens.Combinators as Proto
import qualified Data.ProtoLens.Field
import qualified Data.Serialize as S
import qualified Data.Set as Set
import Data.Word
import Foreign
import Lens.Micro.Platform
import qualified Proto.Concordium.Types as Proto
import qualified Proto.Concordium.Types_Fields as ProtoFields

import Concordium.Crypto.EncryptedTransfers
import Concordium.ID.Types
import Concordium.Types
import Concordium.Types.Accounts
import qualified Concordium.Types.Queries as QueryTypes

import qualified Concordium.External as Ext -- TODO: This is not an ideal configuration.
import Concordium.MultiVersion (
    MVR (..),
 )
import qualified Concordium.Queries as Q

import Concordium.Common.Time
import Concordium.Common.Version
import Concordium.Crypto.SHA256 (DigestSize, Hash (Hash))
import Concordium.Crypto.SignatureScheme (VerifyKey (..))
import Concordium.Types.Accounts.Releases
import Concordium.Types.Execution
import qualified Concordium.Wasm as Wasm
import Data.Text (Text)
import Data.Time (UTCTime)
import Concordium.Wasm (InstanceInfo(iiSourceModule))
import Concordium.Types.Updates (UpdateType(..))

{- |An opaque representation of a Rust vector. This is used by callbacks to copy
 the message generated by a query to Rust, so it can be forwarded back to the
 caller.
-}
data ReceiverVec

-- |A type of callback that copies the data to the end of the given vector.
type CopyToVecCallback = Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()

{- |An opaque representation of a channel to which streaming responses can write
 data. When a request is made to an endpoint with a streaming response then a
 channel is created in Rust code. One endpoint is passed to Haskell and the
 other end (the receiver) is kept by the request handler. Haskell code is
 meant to spawn a background thread that streams data into the channel, using
 the provided 'ChannelSendCallback' to write each item into the channel.
-}
data SenderChannel

{- |The type of callbacks to enqueue the given data in the channel. The response
 code of 0 means data was successfully enqueued, 1 means that the channel is
 now full, so data was not enqueued. The sender should try again. Response of
 2 means the channel is dead. In this case the provided 'SenderChannel' is
 dropped, and the callback must not be invoked again.
-}
type ChannelSendCallback = Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callChannelSendCallback :: FunPtr ChannelSendCallback -> ChannelSendCallback

-- |Boilerplate wrapper to invoke C callbacks.
foreign import ccall "dynamic" callCopyToVecCallback :: FunPtr CopyToVecCallback -> CopyToVecCallback

mkSerialize ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        BS.ByteString
    , S.Serialize a
    ) =>
    a ->
    b
mkSerialize ek = Proto.make (ProtoFields.value .= S.encode ek)

mkWord64 ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word64
    , Coercible a Word64
    ) =>
    a ->
    b
mkWord64 a = Proto.make (ProtoFields.value .= coerce a)

mkWord32 ::
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word32
    , Coercible a Word32
    ) =>
    a ->
    b
mkWord32 a = Proto.make (ProtoFields.value .= coerce a)

mkWord8 ::
    forall a b.
    ( Proto.Message b
    , Data.ProtoLens.Field.HasField
        b
        "value"
        Word32
    , Coercible a Word8
    ) =>
    a ->
    b
mkWord8 a = Proto.make (ProtoFields.value .= (fromIntegral (coerce a :: Word8) :: Word32))

-- |A helper class analogous to something like Aeson's ToJSON.
-- It exists to make it more manageable to convert the internal Haskell types to
-- their Protobuf equivalents.
class ToProto a where
    -- |The corresponding Proto type.
    type Output a
    -- |A conversion function from the type to its protobuf equivalent.
    toProto :: a -> Output a

instance ToProto Amount where
    type Output Amount = Proto.Amount
    toProto = mkWord64

instance ToProto BlockHash where
    type Output BlockHash = Proto.BlockHash
    toProto = mkSerialize

instance ToProto TransactionHashV0 where
    type Output TransactionHashV0 = Proto.TransactionHash
    toProto = mkSerialize

instance ToProto ModuleRef where
    type Output ModuleRef = Proto.ModuleRef
    toProto = mkSerialize

instance ToProto Wasm.WasmModule where
    type Output Wasm.WasmModule = Proto.ModuleSource
    toProto = mkSerialize

instance ToProto Wasm.InstanceInfo where
    type Output Wasm.InstanceInfo = Proto.InstanceInfo
    toProto Wasm.InstanceInfoV0{..} = Proto.make ( ProtoFields.v0 .= Proto.make ( do
      ProtoFields.owner .= mkSerialize iiOwner
      ProtoFields.amount .= mkWord64 iiAmount
      ProtoFields.methods .= (toProto <$> Set.toList iiMethods)
      ProtoFields.name .= toProto iiName
      ProtoFields.sourceModule .= toProto iiSourceModule
      ProtoFields.model .= toProto iiModel))
    toProto Wasm.InstanceInfoV1{..} = Proto.make ( ProtoFields.v1 .= Proto.make ( do
      ProtoFields.owner .= mkSerialize iiOwner
      ProtoFields.amount .= mkWord64 iiAmount
      ProtoFields.methods .= (toProto <$> Set.toList iiMethods)
      ProtoFields.name .= toProto iiName
      ProtoFields.sourceModule .= toProto iiSourceModule))

instance ToProto Wasm.ReceiveName where
  type Output Wasm.ReceiveName = Proto.ReceiveName
  toProto name = Proto.make $ ProtoFields.value .= Wasm.receiveName name

instance ToProto Wasm.InitName where
  type Output Wasm.InitName = Proto.InitName
  toProto name = Proto.make $ ProtoFields.value .= Wasm.initName name

instance ToProto Wasm.ContractState where
  type Output Wasm.ContractState = Proto.ContractState
  toProto = mkSerialize

instance ToProto ContractAddress where
  type Output ContractAddress = Proto.ContractAddress
  toProto ContractAddress{..} = Proto.make $ do
    ProtoFields.index .= _contractIndex contractIndex
    ProtoFields.subindex .= _contractSubindex contractSubindex

instance ToProto BlockHeight where
    type Output BlockHeight = Proto.BlockHeight
    toProto = mkWord64

instance ToProto AccountAddress where
    type Output AccountAddress = Proto.AccountAddress
    toProto = mkSerialize

instance ToProto Nonce where
    type Output Nonce = Proto.Nonce
    toProto = mkWord64

instance ToProto AccountThreshold where
    type Output AccountThreshold = Proto.AccountThreshold
    toProto = mkWord8

instance ToProto SignatureThreshold where
    type Output SignatureThreshold = Proto.SignatureThreshold
    toProto = mkWord8

instance ToProto Threshold where
    type Output Threshold = Proto.ArThreshold
    toProto = mkWord8

instance ToProto AccountIndex where
    type Output AccountIndex = Proto.AccountIndex
    toProto = mkWord64

instance ToProto BakerId where
    type Output BakerId = Proto.BakerId
    toProto = mkWord64

instance ToProto DelegatorId where
    type Output DelegatorId = Proto.DelegatorId
    toProto v = Proto.make $ ProtoFields.id .= toProto (delegatorAccountIndex v)

instance ToProto EncryptedAmount where
    type Output EncryptedAmount = Proto.EncryptedAmount
    toProto = mkSerialize

instance ToProto AccountEncryptedAmount where
    type Output AccountEncryptedAmount = Proto.EncryptedBalance
    toProto encBal =
        case _aggregatedAmount encBal of
            Nothing -> Proto.make mkEncryptedBalance
            Just (aggAmount, numAgg) -> Proto.make $ do
                mkEncryptedBalance
                ProtoFields.aggregatedAmount .= toProto aggAmount
                ProtoFields.numAggregated .= numAgg
      where
        mkEncryptedBalance = do
            ProtoFields.selfAmount .= toProto (_selfAmount encBal)
            ProtoFields.startIndex .= coerce (_startIndex encBal)

instance ToProto AccountReleaseSummary where
    type Output AccountReleaseSummary = Proto.ReleaseSchedule
    toProto ars = Proto.make $ do
        ProtoFields.total .= toProto (releaseTotal ars)
        ProtoFields.schedules .= (toProto <$> releaseSchedule ars)

instance ToProto ScheduledRelease where
    type Output ScheduledRelease = Proto.Release
    toProto r = Proto.make $ do
        ProtoFields.timestamp .= coerce (releaseTimestamp r)
        ProtoFields.amount .= toProto (releaseAmount r)
        ProtoFields.transactions .= (toProto <$> releaseTransactions r)

instance ToProto (Timestamp, Amount) where
  type Output (Timestamp, Amount) = Proto.NewRelease
  toProto (t, a) = Proto.make $ do
      ProtoFields.timestamp .= coerce t
      ProtoFields.amount .= toProto a

instance ToProto (StakePendingChange' UTCTime) where
    type Output (StakePendingChange' UTCTime) = Maybe Proto.StakePendingChange
    toProto NoChange = Nothing
    toProto (ReduceStake newStake effectiveTime) =
        Just . Proto.make $
            ( ProtoFields.reduce
                .= Proto.make
                    ( do
                        ProtoFields.newStake .= toProto newStake
                        ProtoFields.effectiveTime .= fromIntegral (utcTimeToTimestamp effectiveTime)
                    )
            )
    toProto (RemoveStake effectiveTime) =
        Just . Proto.make $ (ProtoFields.remove .= fromIntegral (utcTimeToTimestamp effectiveTime))

instance ToProto BakerInfo where
    type Output BakerInfo = Proto.BakerInfo
    toProto BakerInfo{..} =
        Proto.make
            ( do
                ProtoFields.bakerId .= mkWord64 _bakerIdentity
                ProtoFields.electionKey .= mkSerialize _bakerElectionVerifyKey
                ProtoFields.signatureKey .= mkSerialize _bakerSignatureVerifyKey
                ProtoFields.aggregationKey .= mkSerialize _bakerAggregationVerifyKey
            )

instance ToProto OpenStatus where
    type Output OpenStatus = Proto.OpenStatus
    toProto OpenForAll = Proto.OPEN_STATUS_OPENFORALL
    toProto ClosedForNew = Proto.OPEN_STATUS_CLOSEDFORNEW
    toProto ClosedForAll = Proto.OPEN_STATUS_CLOSEDFORALL

instance ToProto UrlText where
    type Output UrlText = Text
    toProto (UrlText s) = s

instance ToProto AmountFraction where
    type Output AmountFraction = Proto.AmountFraction
    toProto (AmountFraction ppht) = Proto.make (ProtoFields.partsPerHundredThousand .= fromIntegral ppht)

instance ToProto CommissionRates where
    type Output CommissionRates = Proto.CommissionRates
    toProto CommissionRates{..} = Proto.make $ do
        ProtoFields.finalization .= toProto _finalizationCommission
        ProtoFields.baking .= toProto _bakingCommission
        ProtoFields.transaction .= toProto _transactionCommission

instance ToProto BakerPoolInfo where
    type Output BakerPoolInfo = Proto.BakerPoolInfo
    toProto BakerPoolInfo{..} = Proto.make $ do
        ProtoFields.openStatus .= toProto _poolOpenStatus
        ProtoFields.url .= toProto _poolMetadataUrl
        ProtoFields.commissionRates .= toProto _poolCommissionRates

instance ToProto AccountStakingInfo where
    type Output AccountStakingInfo = Maybe Proto.AccountStakingInfo
    toProto AccountStakingNone = Nothing
    toProto AccountStakingBaker{..} =
        Just . Proto.make $
            ( do
                ProtoFields.baker
                    .= Proto.make
                        ( do
                            ProtoFields.stakedAmount .= toProto asiStakedAmount
                            ProtoFields.restakeEarnings .= asiStakeEarnings
                            ProtoFields.bakerInfo .= toProto asiBakerInfo
                            ProtoFields.maybe'pendingChange .= toProto asiPendingChange
                            case asiPoolInfo of
                                Nothing -> return ()
                                Just asipi -> ProtoFields.poolInfo .= toProto asipi
                        )
            )
    toProto AccountStakingDelegated{..} =
        Just . Proto.make $
            ( do
                ProtoFields.delegate
                    .= Proto.make
                        ( do
                            ProtoFields.stakedAmount .= mkWord64 asiStakedAmount
                            ProtoFields.restakeEarnings .= asiStakeEarnings
                            ProtoFields.target .= toProto asiDelegationTarget
                            ProtoFields.maybe'pendingChange .= toProto asiDelegationPendingChange
                        )
            )

instance ToProto DelegationTarget where
  type Output DelegationTarget = Proto.DelegationTarget
  toProto DelegatePassive = Proto.make $ ProtoFields.passive .= Proto.defMessage
  toProto (DelegateToBaker bi) = Proto.make $ ProtoFields.baker .= toProto bi

instance ToProto (Map.Map CredentialIndex (Versioned RawAccountCredential)) where
    type Output (Map.Map CredentialIndex (Versioned RawAccountCredential)) = Map.Map Word32 Proto.AccountCredential
    toProto = Map.fromAscList . map (\(k, v) -> (fromIntegral k, toProto (vValue v))) . Map.toAscList

instance ToProto CredentialPublicKeys where
    type Output CredentialPublicKeys = Proto.CredentialPublicKeys
    toProto CredentialPublicKeys{..} = Proto.make $ do
        ProtoFields.threshold .= mkWord8 credThreshold
        ProtoFields.keys .= (Map.fromAscList . map convertKey . Map.toAscList $ credKeys)
      where
        convertKey (ki, VerifyKeyEd25519 key) = (fromIntegral ki, Proto.make $ ProtoFields.ed25519Key .= S.encode key)

instance ToProto Policy where
    type Output Policy = Proto.Policy
    toProto Policy{..} = Proto.make $ do
        ProtoFields.createdAt .= toProto pCreatedAt
        ProtoFields.validTo .= toProto pValidTo
        ProtoFields.attributes .= mkAttributes pItems
      where
        mkAttributes =
            Map.fromAscList
                . map (\(AttributeTag tag, value) -> (fromIntegral tag, S.runPut (S.putShortByteString (coerce value))))
                . Map.toAscList

instance ToProto YearMonth where
    type Output YearMonth = Proto.YearMonth
    toProto YearMonth{..} = Proto.make $ do
        ProtoFields.year .= fromIntegral ymYear
        ProtoFields.month .= fromIntegral ymMonth

instance ToProto RawCredentialRegistrationID where
    type Output RawCredentialRegistrationID = Proto.CredentialRegistrationId
    toProto = mkSerialize

instance ToProto CredentialRegistrationID where
  type Output CredentialRegistrationID = Proto.CredentialRegistrationId
  toProto = toProto . toRawCredRegId

instance ToProto IdentityProviderIdentity where
    type Output IdentityProviderIdentity = Proto.IdentityProviderIdentity
    toProto = mkWord32

instance ToProto Commitment where
    type Output Commitment = Proto.Commitment
    toProto = mkSerialize

instance ToProto CredentialDeploymentCommitments where
    type Output CredentialDeploymentCommitments = Proto.CredentialCommitments
    toProto CredentialDeploymentCommitments{..} = Proto.make $ do
        ProtoFields.prf .= toProto cmmPrf
        ProtoFields.credCounter .= toProto cmmCredCounter
        ProtoFields.maxAccounts .= toProto cmmMaxAccounts
        ProtoFields.attributes
            .= ( Map.fromAscList
                    . map (\(AttributeTag tag, v) -> (fromIntegral tag :: Word32, toProto v))
                    . Map.toAscList
               )
                cmmAttributes
        ProtoFields.idCredSecSharingCoeff .= map toProto cmmIdCredSecSharingCoeff

instance ToProto RawAccountCredential where
    type Output RawAccountCredential = Proto.AccountCredential
    toProto (InitialAC InitialCredentialDeploymentValues{..}) =
        Proto.make $
            ProtoFields.initial
                .= Proto.make
                    ( do
                        ProtoFields.keys .= toProto icdvAccount
                        ProtoFields.credId .= toProto icdvRegId
                        ProtoFields.ipId .= toProto icdvIpId
                        ProtoFields.policy .= toProto icdvPolicy
                    )
    toProto (NormalAC CredentialDeploymentValues{..} commitments) =
        Proto.make $
            ProtoFields.normal
                .= Proto.make
                    ( do
                        ProtoFields.keys .= toProto cdvPublicKeys
                        ProtoFields.credId .= toProto cdvCredId
                        ProtoFields.ipId .= toProto cdvIpId
                        ProtoFields.policy .= toProto cdvPolicy
                        ProtoFields.arThreshold .= toProto cdvThreshold
                        ProtoFields.commitments .= toProto commitments
                    )

instance ToProto AccountEncryptionKey where
    type Output AccountEncryptionKey = Proto.EncryptionKey
    toProto = mkSerialize

instance ToProto AccountInfo where
    type Output AccountInfo = Proto.AccountInfo
    toProto AccountInfo{..} = Proto.make $ do
        ProtoFields.nonce .= toProto aiAccountNonce
        ProtoFields.amount .= toProto aiAccountAmount
        ProtoFields.schedule .= toProto aiAccountReleaseSchedule
        ProtoFields.creds .= toProto aiAccountCredentials
        ProtoFields.threshold .= toProto aiAccountThreshold
        ProtoFields.encryptedBalance .= toProto aiAccountEncryptedAmount
        ProtoFields.encryptionKey .= toProto aiAccountEncryptionKey
        ProtoFields.index .= toProto aiAccountIndex
        ProtoFields.address .= toProto aiAccountAddress
        ProtoFields.maybe'stake .= toProto aiStakingInfo

instance ToProto Wasm.Parameter where
  type Output Wasm.Parameter = Proto.Parameter
  toProto = mkSerialize

instance ToProto RejectReason where
  type Output RejectReason = Proto.RejectReason
  toProto r = case r of
    ModuleNotWF -> Proto.make $ ProtoFields.moduleNotWf .= Proto.defMessage
    ModuleHashAlreadyExists moduleRef -> Proto.make $ ProtoFields.moduleHashAlreadyExists . ProtoFields.contents .= toProto moduleRef
    InvalidAccountReference addr -> Proto.make $ ProtoFields.invalidAccountReference . ProtoFields.contents .= toProto addr
    InvalidInitMethod moduleRef initName -> Proto.make $ ProtoFields.invalidInitMethod .= Proto.make (do
                                                                                            ProtoFields.moduleRef .= toProto moduleRef
                                                                                            ProtoFields.initName .= toProto initName)
    InvalidReceiveMethod moduleRef receiveName -> Proto.make $ ProtoFields.invalidReceiveMethod .= Proto.make (do
                                                                                            ProtoFields.moduleRef .= toProto moduleRef
                                                                                            ProtoFields.receiveName .= toProto receiveName)
    InvalidModuleReference moduleRef -> Proto.make $ ProtoFields.invalidModuleReference . ProtoFields.contents .= toProto moduleRef
    InvalidContractAddress addr -> Proto.make $ ProtoFields.invalidContractAddress . ProtoFields.contents .= toProto addr
    RuntimeFailure -> Proto.make $ ProtoFields.runtimeFailure .= Proto.defMessage
    AmountTooLarge addr amount -> Proto.make $ ProtoFields.amountTooLarge .= Proto.make (do
                                                                                         ProtoFields.address .= toProto addr
                                                                                         ProtoFields.amount .= toProto amount)
    SerializationFailure -> Proto.make $ ProtoFields.serializationFailure .= Proto.defMessage
    OutOfEnergy -> Proto.make $ ProtoFields.outOfEnergy .= Proto.defMessage
    RejectedInit{..} -> Proto.make $ ProtoFields.rejectedInit . ProtoFields.rejectReason .= rejectReason
    RejectedReceive{..} -> Proto.make $ ProtoFields.rejectedReceive .= Proto.make (do
                                                                        ProtoFields.rejectReason .= rejectReason
                                                                        ProtoFields.contractAddress .= toProto contractAddress
                                                                        ProtoFields.receiveName .= toProto receiveName
                                                                        ProtoFields.parameter .= toProto parameter)
    InvalidProof -> Proto.make $ ProtoFields.invalidProof .= Proto.defMessage
    AlreadyABaker bakerId -> Proto.make $ ProtoFields.alreadyABaker . ProtoFields.contents .= toProto bakerId
    NotABaker addr -> Proto.make $ ProtoFields.notABaker . ProtoFields.contents .= toProto addr
    InsufficientBalanceForBakerStake -> Proto.make $ ProtoFields.insufficientBalanceForBakerStake .= Proto.defMessage
    StakeUnderMinimumThresholdForBaking -> Proto.make $ ProtoFields.stakeUnderMinimumThresholdForBaking .= Proto.defMessage
    BakerInCooldown -> Proto.make $ ProtoFields.bakerInCooldown .= Proto.defMessage
    DuplicateAggregationKey k -> Proto.make $ ProtoFields.duplicateAggregationKey . ProtoFields.contents .= mkSerialize k
    NonExistentCredentialID -> Proto.make $ ProtoFields.nonExistentCredentialId .= Proto.defMessage
    KeyIndexAlreadyInUse -> Proto.make $ ProtoFields.keyIndexAlreadyInUse .= Proto.defMessage
    InvalidAccountThreshold -> Proto.make $ ProtoFields.invalidAccountThreshold .= Proto.defMessage
    InvalidCredentialKeySignThreshold -> Proto.make $ ProtoFields.invalidCredentialKeySignThreshold .= Proto.defMessage
    InvalidEncryptedAmountTransferProof -> Proto.make $ ProtoFields.invalidEncryptedAmountTransferProof .= Proto.defMessage
    InvalidTransferToPublicProof -> Proto.make $ ProtoFields.invalidTransferToPublicProof .= Proto.defMessage
    EncryptedAmountSelfTransfer addr -> Proto.make $ ProtoFields.encryptedAmountSelfTransfer . ProtoFields.contents .= toProto addr
    InvalidIndexOnEncryptedTransfer -> Proto.make $ ProtoFields.invalidIndexOnEncryptedTransfer .= Proto.defMessage
    ZeroScheduledAmount -> Proto.make $ ProtoFields.zeroScheduledAmount .= Proto.defMessage
    NonIncreasingSchedule -> Proto.make $ ProtoFields.nonIncreasingSchedule .= Proto.defMessage
    FirstScheduledReleaseExpired -> Proto.make $ ProtoFields.firstScheduledReleaseExpired .= Proto.defMessage
    ScheduledSelfTransfer addr -> Proto.make $ ProtoFields.scheduledSelfTransfer . ProtoFields.contents .= toProto addr
    InvalidCredentials -> Proto.make $ ProtoFields.invalidCredentials .= Proto.defMessage
    DuplicateCredIDs ids -> Proto.make $ ProtoFields.duplicateCredIds . ProtoFields.contents .= (toProto <$> ids)
    NonExistentCredIDs ids -> Proto.make $ ProtoFields.nonExistentCredIds . ProtoFields.contents .= (toProto <$> ids)
    RemoveFirstCredential -> Proto.make $ ProtoFields.removeFirstCredential .= Proto.defMessage
    CredentialHolderDidNotSign -> Proto.make $ ProtoFields.credentialHolderDidNotSign .= Proto.defMessage
    NotAllowedMultipleCredentials -> Proto.make $ ProtoFields.notAllowedMultipleCredentials .= Proto.defMessage
    NotAllowedToReceiveEncrypted -> Proto.make $ ProtoFields.notAllowedToReceiveEncrypted .= Proto.defMessage
    NotAllowedToHandleEncrypted -> Proto.make $ ProtoFields.notAllowedToHandleEncrypted .= Proto.defMessage
    MissingBakerAddParameters -> Proto.make $ ProtoFields.missingBakerAddParameters .= Proto.defMessage
    FinalizationRewardCommissionNotInRange -> Proto.make $ ProtoFields.finalizationRewardCommissionNotInRange .= Proto.defMessage
    BakingRewardCommissionNotInRange -> Proto.make $ ProtoFields.bakingRewardCommissionNotInRange .= Proto.defMessage
    TransactionFeeCommissionNotInRange -> Proto.make $ ProtoFields.transactionFeeCommissionNotInRange .= Proto.defMessage
    AlreadyADelegator -> Proto.make $ ProtoFields.alreadyADelegator .= Proto.defMessage
    InsufficientBalanceForDelegationStake -> Proto.make $ ProtoFields.insufficientBalanceForDelegationStake .= Proto.defMessage
    MissingDelegationAddParameters -> Proto.make $ ProtoFields.missingDelegationAddParameters .= Proto.defMessage
    InsufficientDelegationStake -> Proto.make $ ProtoFields.insufficientDelegationStake .= Proto.defMessage
    DelegatorInCooldown -> Proto.make $ ProtoFields.delegatorInCooldown .= Proto.defMessage
    NotADelegator addr -> Proto.make $ ProtoFields.notADelegator . ProtoFields.contents .= toProto addr
    DelegationTargetNotABaker bakerId -> Proto.make $ ProtoFields.delegationTargetNotABaker . ProtoFields.contents .= toProto bakerId
    StakeOverMaximumThresholdForPool -> Proto.make $ ProtoFields.stakeOverMaximumThresholdForPool .= Proto.defMessage
    PoolWouldBecomeOverDelegated -> Proto.make $ ProtoFields.poolWouldBecomeOverDelegated .= Proto.defMessage
    PoolClosed -> Proto.make $ ProtoFields.poolClosed .= Proto.defMessage

toTransactionStatus :: QueryTypes.TransactionStatus -> Either ConversionError Proto.TransactionStatus
toTransactionStatus ts = case ts of
  QueryTypes.Received -> Right . Proto.make $ ProtoFields.received .= Proto.defMessage
  QueryTypes.Finalized bh trx -> do
    bis <- toBis trx
    trxInBlock <- toTrxInBlock bh bis
    Right . Proto.make $ ProtoFields.finalized . ProtoFields.outcome .= trxInBlock
  QueryTypes.Committed trxs -> do
    outcomes <- mapM (\(bh, trx) -> toTrxInBlock bh =<< toBis trx) $ Map.toList trxs
    Right . Proto.make $ ProtoFields.committed . ProtoFields.outcomes .= outcomes
  where
    toBis Nothing = Left CEInvalidTransactionResult -- TODO: Throw internal error here?
    toBis (Just t) = toBlockItemSummary t

    toTrxInBlock bh bis = Right . Proto.make $ do
      ProtoFields.blockHash .= toProto bh
      ProtoFields.outcome .= bis

toBlockItemSummary :: TransactionSummary -> Either ConversionError Proto.BlockItemSummary
toBlockItemSummary TransactionSummary{..} = case tsType of
  TSTAccountTransaction tty -> do
    sender <- case tsSender of
      Nothing -> Left CEInvalidTransactionResult
      Just acc -> Right acc
    details <- convertAccountTransaction tty tsCost sender tsResult
    Right $ Proto.make $ do
        ProtoFields.index .= mkWord64 tsIndex
        ProtoFields.energyCost .= toProto tsEnergyCost
        ProtoFields.hash .= toProto tsHash
        ProtoFields.accountTransaction .= details
  _ -> undefined

data ConversionError
  = CEFailedAccountCreation
  | CEInvalidAccountCreation
  | CEFailedUpdate
  | CEInvalidUpdateResult
  | CEInvalidTransactionResult
  deriving Eq

instance ToProto Wasm.WasmVersion where
  type Output Wasm.WasmVersion = Proto.ContractVersion
  toProto Wasm.V0 = Proto.V0
  toProto Wasm.V1 = Proto.V1

instance ToProto Wasm.ContractEvent where
  type Output Wasm.ContractEvent = Proto.ContractEvent
  toProto = mkSerialize

type BakerAddedEvent = (BakerKeysEvent, Amount, Bool)

instance ToProto BakerAddedEvent where
  type Output BakerAddedEvent = Proto.BakerEvent'BakerAdded
  toProto (keysEvent, stake, restakeEarnings) = Proto.make $ do
    ProtoFields.keysEvent .= toProto keysEvent
    ProtoFields.stake .= toProto stake
    ProtoFields.restakeEarnings .= restakeEarnings

type BakerKeysEvent = (BakerId, AccountAddress, BakerSignVerifyKey, BakerElectionVerifyKey, BakerAggregationVerifyKey)
instance ToProto BakerKeysEvent where
  type Output BakerKeysEvent = Proto.BakerKeysEvent
  toProto (bakerId, addr, signKey, electionKey, aggregationKey) = Proto.make $ do
    ProtoFields.bakerId .= toProto bakerId
    ProtoFields.account .= toProto addr
    ProtoFields.signKey .= toProto signKey
    ProtoFields.electionKey .= toProto electionKey
    ProtoFields.aggregationKey .= toProto aggregationKey

instance ToProto BakerSignVerifyKey where
  type Output BakerSignVerifyKey = Proto.BakerSignatureVerifyKey
  toProto = mkSerialize

instance ToProto BakerElectionVerifyKey where
  type Output BakerElectionVerifyKey = Proto.BakerElectionVerifyKey
  toProto = mkSerialize

instance ToProto BakerAggregationVerifyKey where
  type Output BakerAggregationVerifyKey = Proto.BakerAggregationVerifyKey
  toProto = mkSerialize

instance ToProto Memo where
  type Output Memo = Proto.Memo
  toProto = mkSerialize

instance ToProto RegisteredData where
  type Output RegisteredData = Proto.RegisteredData
  toProto = mkSerialize

convertAccountTransaction
  :: Maybe TransactionType
  -> Amount
  -> AccountAddress
  -> ValidResult
  -> Either ConversionError Proto.AccountTransactionDetails
convertAccountTransaction ty cost sender result = case ty of
    Nothing -> Right . mkNone $ SerializationFailure
    Just ty' -> case result of
        TxReject rejectReason -> Right . mkNone $ rejectReason
        TxSuccess events -> case ty' of
            TTDeployModule -> mkSuccess <$> do
                v <- case events of
                    [ModuleDeployed moduleRef] -> Right $ toProto moduleRef
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.moduleDeployed . ProtoFields.moduleRef .= v
            TTInitContract -> mkSuccess <$> do
                v <- case events of
                    [ContractInitialized {..}] -> Right $ Proto.make $ do
                       ProtoFields.contractVersion .= toProto ecContractVersion
                       ProtoFields.originRef .= toProto ecRef
                       ProtoFields.address .= toProto ecAddress
                       ProtoFields.amount .= toProto ecAmount
                       ProtoFields.initName .= toProto ecInitName
                       ProtoFields.events .= map toProto ecEvents
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.contractInitialized . ProtoFields.contents .= v
            TTUpdate-> mkSuccess <$> do
                let toContractEvent = \case
                        Updated{..} -> Right . Proto.make $ ProtoFields.updated . ProtoFields.contents .= Proto.make (do
                            ProtoFields.contractVersion .= toProto euContractVersion
                            ProtoFields.address .= toProto euAddress
                            ProtoFields.instigator .= toProto euInstigator
                            ProtoFields.amount .= toProto euAmount
                            ProtoFields.parameter .= toProto euMessage
                            ProtoFields.receiveName .= toProto euReceiveName
                            ProtoFields.events .= map toProto euEvents)
                        Transferred{..} -> do
                            from <- case etFrom of
                                AddressAccount _ -> Left CEInvalidTransactionResult
                                AddressContract addr -> Right addr
                            to' <- case etTo of
                                AddressAccount addr -> Right addr
                                AddressContract _ -> Left CEInvalidTransactionResult
                            Right . Proto.make $ ProtoFields.transferred .= Proto.make (do
                                ProtoFields.from .= toProto from
                                ProtoFields.amount .= toProto etAmount
                                ProtoFields.to .= toProto to')
                        Interrupted{..} -> Right . Proto.make $ ProtoFields.interrupted .= Proto.make (do
                            ProtoFields.address .= toProto iAddress
                            ProtoFields.events .= map toProto iEvents)
                        Resumed{..} -> Right . Proto.make $ ProtoFields.resumed .= Proto.make (do
                            ProtoFields.address .= toProto rAddress
                            ProtoFields.success .= rSuccess)
                        _ -> Left CEInvalidTransactionResult
                v <- mapM toContractEvent events
                Right . Proto.make $ ProtoFields.contractUpdateIssued . ProtoFields.effects .= v
            TTTransfer-> mkSuccess <$> do
                v <- case events of
                    [Transferred{..}] -> case etTo of
                        AddressContract _ -> Left CEInvalidTransactionResult
                        AddressAccount receiver -> Right . Proto.make $ do
                            ProtoFields.amount .= toProto etAmount
                            ProtoFields.to .= toProto receiver
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.accountTransfer .= v
            TTTransferWithMemo -> mkSuccess <$> do
                v <- case events of
                    [Transferred{..}, TransferMemo{..}] -> case etTo of
                        AddressContract _ -> Left CEInvalidTransactionResult
                        AddressAccount receiver -> Right . Proto.make $ do
                            ProtoFields.amount .= toProto etAmount
                            ProtoFields.to .= toProto receiver
                            ProtoFields.memo .= toProto tmMemo
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.accountTransfer .= v
            TTAddBaker -> mkSuccess <$> do
                v <- case events of
                    [BakerAdded{..}] -> Right $ toProto ((ebaBakerId, ebaAccount, ebaSignKey, ebaElectionKey, ebaAggregationKey), ebaStake, ebaRestakeEarnings)
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerAdded .= v
            TTRemoveBaker -> mkSuccess <$> do
                v <- case events of
                    [BakerRemoved{..}] -> Right $ toProto ebrBakerId
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerRemoved . ProtoFields.bakerId .= v
            TTUpdateBakerStake -> mkSuccess <$> do
                v <- case events of
                    [] -> Right Proto.defMessage -- TODO: Is it correct that if the stake is unchanged, no events occur?
                    [BakerStakeIncreased{..}] -> Right . Proto.make $ do
                        ProtoFields.bakerId .= toProto ebsiBakerId
                        ProtoFields.newStake .= toProto ebsiNewStake
                        ProtoFields.increased .= True
                    [BakerStakeDecreased{..}] -> Right . Proto.make $ do
                        ProtoFields.bakerId .= toProto ebsiBakerId
                        ProtoFields.newStake .= toProto ebsiNewStake
                        ProtoFields.increased .= False
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerStakeUpdated . ProtoFields.contents .= v
            TTUpdateBakerRestakeEarnings -> mkSuccess <$> do
                v <- case events of
                    [BakerSetRestakeEarnings{..}] -> Right $ Proto.make $ do
                        ProtoFields.bakerId .= toProto ebsreBakerId
                        ProtoFields.restakeEarnings .= ebsreRestakeEarnings
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerRestakeEarningsUpdated .= v
            TTUpdateBakerKeys -> mkSuccess <$> do
                v <- case events of
                    [BakerKeysUpdated{..}] -> Right $ toProto (ebkuBakerId, ebkuAccount, ebkuSignKey, ebkuElectionKey, ebkuAggregationKey)
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.bakerKeysUpdated . ProtoFields.contents .= v
            TTEncryptedAmountTransfer -> mkSuccess <$> do
                v <- case events of
                    [EncryptedAmountsRemoved{..}, NewEncryptedAmount{..}] -> let
                        removed = Proto.make $ do
                            ProtoFields.account .= toProto earAccount
                            ProtoFields.newAmount .= toProto earNewAmount
                            ProtoFields.inputAmount .= toProto earInputAmount
                            ProtoFields.upToIndex .= theAggIndex earUpToIndex
                        added = Proto.make $ do
                            ProtoFields.receiver .= toProto neaAccount
                            ProtoFields.newIndex .= theIndex neaNewIndex
                            ProtoFields.encryptedAmount .= toProto neaEncryptedAmount
                        in Right . Proto.make $ do
                            ProtoFields.removed .= removed
                            ProtoFields.added .= added
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.encryptedAmountTransferred .= v
            TTEncryptedAmountTransferWithMemo -> mkSuccess <$> do
                v <- case events of
                    [EncryptedAmountsRemoved{..}, NewEncryptedAmount{..}, TransferMemo{..}] -> let
                        removed = Proto.make $ do
                            ProtoFields.account .= toProto earAccount
                            ProtoFields.newAmount .= toProto earNewAmount
                            ProtoFields.inputAmount .= toProto earInputAmount
                            ProtoFields.upToIndex .= theAggIndex earUpToIndex
                        added = Proto.make $ do
                            ProtoFields.receiver .= toProto neaAccount
                            ProtoFields.newIndex .= theIndex neaNewIndex
                            ProtoFields.encryptedAmount .= toProto neaEncryptedAmount
                        in Right . Proto.make $ do
                            ProtoFields.removed .= removed
                            ProtoFields.added .= added
                            ProtoFields.memo .= toProto tmMemo
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.encryptedAmountTransferred .= v
            TTTransferToEncrypted -> mkSuccess <$> do
                v <- case events of
                    [EncryptedSelfAmountAdded{..}] -> Right . Proto.make $ do
                        ProtoFields.account .= toProto eaaAccount
                        ProtoFields.newAmount .= toProto eaaNewAmount
                        ProtoFields.amount .= toProto eaaAmount
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredToEncrypted . ProtoFields.contents .= v
            TTTransferToPublic -> mkSuccess <$> do
                v <- case events of
                    [EncryptedAmountsRemoved{..}, AmountAddedByDecryption{..}] -> let
                        removed = Proto.make $ do
                            ProtoFields.account .= toProto earAccount
                            ProtoFields.newAmount .= toProto earNewAmount
                            ProtoFields.inputAmount .= toProto earInputAmount
                            ProtoFields.upToIndex .= theAggIndex earUpToIndex
                        in Right . Proto.make $ do
                            ProtoFields.removed .= removed
                            ProtoFields.amount .= toProto aabdAmount
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredToPublic .= v
            TTTransferWithSchedule -> mkSuccess <$> do
                v <- case events of
                    [TransferredWithSchedule{..}] -> Right . Proto.make $ do
                        ProtoFields.to .= toProto etwsTo
                        ProtoFields.amount .= map toProto etwsAmount
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredWithSchedule .= v
            TTTransferWithScheduleAndMemo -> mkSuccess <$> do
                v <- case events of
                    [TransferredWithSchedule{..}, TransferMemo{..}] -> Right . Proto.make $ do
                        ProtoFields.to .= toProto etwsTo
                        ProtoFields.amount .= map toProto etwsAmount
                        ProtoFields.memo .= toProto tmMemo
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.transferredWithSchedule .= v
            TTUpdateCredentialKeys -> mkSuccess <$> do
                v <- case events of
                    [CredentialKeysUpdated{..}] -> Right $ toProto ckuCredId
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.credentialKeysUpdated . ProtoFields.credId .= v
            TTUpdateCredentials -> mkSuccess <$> do
                v <- case events of
                    [CredentialsUpdated{..}] -> Right . Proto.make $ do
                        ProtoFields.newCredIds .= map toProto cuNewCredIds
                        ProtoFields.removedCredIds .= map toProto cuRemovedCredIds
                        ProtoFields.newThreshold .= toProto cuNewThreshold
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.credentialsUpdated .= v
            TTRegisterData -> mkSuccess <$> do
                v <- case events of
                    [DataRegistered{..}] -> Right $ toProto drData
                    _ -> Left CEInvalidTransactionResult
                Right . Proto.make $ ProtoFields.dataRegistered . ProtoFields.contents .= v
            TTConfigureBaker -> mkSuccess <$> do
                let toBakerEvent = \case
                        BakerAdded{..} -> Right . Proto.make $ ProtoFields.bakerAdded .=
                          toProto ((ebaBakerId, ebaAccount, ebaSignKey, ebaElectionKey, ebaAggregationKey), ebaStake, ebaRestakeEarnings)
                        BakerRemoved{..} -> Right . Proto.make $ ProtoFields.bakerRemoved . ProtoFields.bakerId .= toProto ebrBakerId
                        BakerStakeIncreased{..} -> Right . Proto.make $ ProtoFields.bakerStakeIncreased .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsiBakerId
                            ProtoFields.newStake .= toProto ebsiNewStake)
                        BakerStakeDecreased{..} -> Right . Proto.make $ ProtoFields.bakerStakeDecreased .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsiBakerId
                            ProtoFields.newStake .= toProto ebsiNewStake)
                        BakerSetRestakeEarnings{..} -> Right . Proto.make $ ProtoFields.bakerRestakeEarningsUpdated .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsreBakerId
                            ProtoFields.restakeEarnings .= ebsreRestakeEarnings)
                        BakerKeysUpdated{..} -> Right . Proto.make $ ProtoFields.bakerKeysUpdated . ProtoFields.contents .= toProto (ebkuBakerId, ebkuAccount, ebkuSignKey, ebkuElectionKey, ebkuAggregationKey)
                        BakerSetOpenStatus{..} -> Right . Proto.make $ ProtoFields.bakerSetOpenStatus .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsosBakerId
                            ProtoFields.openStatus .= toProto ebsosOpenStatus)
                        BakerSetMetadataURL{..} -> Right . Proto.make $ ProtoFields.bakerSetMetadataUrl .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsmuBakerId
                            ProtoFields.url .= toProto ebsmuMetadataURL)
                        BakerSetTransactionFeeCommission{..} -> Right . Proto.make $ ProtoFields.bakerSetTransactionFeeCommission .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebstfcBakerId
                            ProtoFields.transactionFeeCommission .= toProto ebstfcTransactionFeeCommission)
                        BakerSetBakingRewardCommission{..} -> Right . Proto.make $ ProtoFields.bakerSetBakingRewardCommission .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsbrcBakerId
                            ProtoFields.bakingRewardCommission .= toProto ebsbrcBakingRewardCommission)
                        BakerSetFinalizationRewardCommission{..} -> Right . Proto.make $ ProtoFields.bakerSetFinalizationRewardCommission .= Proto.make (do
                            ProtoFields.bakerId .= toProto ebsfrcBakerId
                            ProtoFields.finalizationRewardCommission .= toProto ebsfrcFinalizationRewardCommission)
                        _ -> Left CEInvalidTransactionResult
                v <- mapM toBakerEvent events
                Right . Proto.make $ ProtoFields.bakerConfigured . ProtoFields.contents .= v
            TTConfigureDelegation -> mkSuccess <$> do
                let toDelegationEvent = \case
                        DelegationStakeIncreased{..} -> Right . Proto.make $ ProtoFields.delegationStakeIncreased .= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsiDelegatorId
                            ProtoFields.newStake .= toProto edsiNewStake)
                        DelegationStakeDecreased{..} -> Right . Proto.make $ ProtoFields.delegationStakeDecreased.= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsdDelegatorId
                            ProtoFields.newStake .= toProto edsdNewStake)
                        DelegationSetRestakeEarnings{..} -> Right . Proto.make $ ProtoFields.delegationSetRestakeEarnings .= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsreDelegatorId
                            ProtoFields.restakeEarnings .= edsreRestakeEarnings)
                        DelegationSetDelegationTarget{..} -> Right . Proto.make $ ProtoFields.delegationSetDelegationTarget .= Proto.make (do
                            ProtoFields.delegatorId .= toProto edsdtDelegatorId
                            ProtoFields.delegationTarget .= toProto edsdtDelegationTarget)
                        DelegationAdded{..} -> Right . Proto.make $ ProtoFields.delegationAdded . ProtoFields.delegatorId .= toProto edaDelegatorId
                        DelegationRemoved{..} -> Right . Proto.make $ ProtoFields.delegationRemoved . ProtoFields.delegatorId .= toProto edrDelegatorId
                        _ -> Left CEInvalidTransactionResult
                v <- mapM toDelegationEvent events
                Right . Proto.make $ ProtoFields.delegationConfigured . ProtoFields.contents .= v
  where
    mkSuccess :: Proto.AccountTransactionEffects -> Proto.AccountTransactionDetails
    mkSuccess effects = Proto.make $ do
      ProtoFields.cost .= toProto cost
      ProtoFields.sender .= toProto sender
      ProtoFields.effects .= effects

    mkNone :: RejectReason -> Proto.AccountTransactionDetails
    mkNone rr = Proto.make $ do
      ProtoFields.cost .= toProto cost
      ProtoFields.sender .= toProto sender
      ProtoFields.effects . ProtoFields.none .=
        (Proto.make $ do
            ProtoFields.rejectReason .= toProto rr
            case ty of
              Nothing -> return ()
              Just ty' -> ProtoFields.transactionType .= toProto ty'
        )

instance ToProto Address where
  type Output Address = Proto.Address
  toProto (AddressAccount addr) = Proto.make $ ProtoFields.account .= toProto addr
  toProto (AddressContract addr) = Proto.make $ ProtoFields.contract .= toProto addr

instance ToProto UpdateType where
  type Output UpdateType = Proto.UpdateType
  toProto UpdateProtocol = Proto.UPDATE_PROTOCOL
  toProto UpdateElectionDifficulty = Proto.UPDATE_ELECTION_DIFFICULTY
  toProto UpdateEuroPerEnergy = Proto.UPDATE_EURO_PER_ENERGY
  toProto UpdateMicroGTUPerEuro = Proto.UPDATE_MICRO_GTU_PER_EURO
  toProto UpdateFoundationAccount = Proto.UPDATE_FOUNDATION_ACCOUNT
  toProto UpdateMintDistribution = Proto.UPDATE_MINT_DISTRIBUTION
  toProto UpdateTransactionFeeDistribution = Proto.UPDATE_TRANSACTION_FEE_DISTRIBUTION
  toProto UpdateGASRewards = Proto.UPDATE_GAS_REWARDS
  toProto UpdatePoolParameters = Proto.UPDATE_POOL_PARAMETERS
  toProto UpdateAddAnonymityRevoker = Proto.ADD_ANONYMITY_REVOKER
  toProto UpdateAddIdentityProvider = Proto.ADD_IDENTITY_PROVIDER
  toProto UpdateRootKeys = Proto.UPDATE_ROOT_KEYS
  toProto UpdateLevel1Keys = Proto.UPDATE_LEVEL1_KEYS
  toProto UpdateLevel2Keys = Proto.UPDATE_LEVEL2_KEYS
  toProto UpdateCooldownParameters = Proto.UPDATE_COOLDOWN_PARAMETERS
  toProto UpdateTimeParameters = Proto.UPDATE_TIME_PARAMETERS


instance ToProto TransactionType where
  type Output TransactionType = Proto.TransactionType
  toProto TTDeployModule = Proto.DEPLOY_MODULE
  toProto TTInitContract = Proto.INIT_CONTRACT
  toProto TTUpdate = Proto.UPDATE
  toProto TTTransfer = Proto.TRANSFER
  toProto TTAddBaker = Proto.ADD_BAKER
  toProto TTRemoveBaker = Proto.REMOVE_BAKER
  toProto TTUpdateBakerStake = Proto.UPDATE_BAKER_STAKE
  toProto TTUpdateBakerRestakeEarnings = Proto.UPDATE_BAKER_RESTAKE_EARNINGS
  toProto TTUpdateBakerKeys = Proto.UPDATE_BAKER_KEYS
  toProto TTUpdateCredentialKeys = Proto.UPDATE_CREDENTIAL_KEYS
  toProto TTEncryptedAmountTransfer = Proto.ENCRYPTED_AMOUNT_TRANSFER
  toProto TTTransferToEncrypted = Proto.TRANSFER_TO_ENCRYPTED
  toProto TTTransferToPublic = Proto.TRANSFER_TO_PUBLIC
  toProto TTTransferWithSchedule = Proto.TRANSFER_WITH_SCHEDULE
  toProto TTUpdateCredentials = Proto.UPDATE_CREDENTIALS
  toProto TTRegisterData = Proto.REGISTER_DATA
  toProto TTTransferWithMemo = Proto.TRANSFER_WITH_MEMO
  toProto TTEncryptedAmountTransferWithMemo = Proto.ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO
  toProto TTTransferWithScheduleAndMemo = Proto.TRANSFER_WITH_SCHEDULE_AND_MEMO
  toProto TTConfigureBaker = Proto.CONFIGURE_BAKER
  toProto TTConfigureDelegation = Proto.CONFIGURE_DELEGATION

instance ToProto Energy where
  type Output Energy = Proto.Energy
  toProto = mkWord64


-- |NB: Assumes the data is at least 32 bytes
decodeBlockHashInput :: Word8 -> Ptr Word8 -> IO Q.BlockHashInput
decodeBlockHashInput 0 _ = return Q.BHIBest
decodeBlockHashInput 1 _ = return Q.BHILastFinal
decodeBlockHashInput _ hsh = Q.BHIGiven . coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

-- |NB: Assumes the data is at least 32 bytes.
decodeTransactionHashInput :: Ptr Word8 -> IO TransactionHash
decodeTransactionHashInput hsh = coerce <$> FBS.create @DigestSize (\p -> copyBytes p hsh 32)

decodeAccountIdentifierInput :: Word8 -> Ptr Word8 -> IO AccountIdentifier
decodeAccountIdentifierInput 0 dta = AccAddress . coerce <$> FBS.create @AccountAddressSize (\p -> copyBytes p dta 32)
decodeAccountIdentifierInput 1 dta = do
    bs <- BS.unsafePackCStringLen (castPtr dta, 48)
    case S.decode bs of
        Left err -> error $ "Precondition violation in FFI call: " ++ err
        Right cid -> return (CredRegID cid)
decodeAccountIdentifierInput 2 dta = AccIndex . AccountIndex <$> peek (castPtr dta)
decodeAccountIdentifierInput n _ = error $ "Unknown account identifier tag: " ++ show n

decodeModuleRefInput :: Ptr Word8 -> IO ModuleRef
decodeModuleRefInput modRef = coerce <$> FBS.create @DigestSize (\p -> copyBytes p modRef 32)

data QueryResult
    = QRSuccess
    | QRNotFound

queryResultCode :: QueryResult -> Int64
queryResultCode QRSuccess = 0
queryResultCode QRNotFound = 1

getAccountInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
    Word8 ->
    -- |Serialized identifier. Length determined by the type.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getAccountInfoV2 cptr blockType blockHashPtr accIdType accIdBytesPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    ai <- decodeAccountIdentifierInput accIdType accIdBytesPtr
    res <- runMVR (Q.getAccountInfo bhi ai) mvr
    returnMessage (copier outVec) outHash res

copyHashTo :: Ptr Word8 -> BlockHash -> IO ()
copyHashTo dest (BlockHash (Hash h)) = FBS.withPtrReadOnly h $ \p -> copyBytes dest p 32

getAccountListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAccountListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mAddresses) <- runMVR (Q.getAccountList bhi) mvr
    case mAddresses of
        Nothing -> return (queryResultCode QRNotFound)
        Just addresses -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) addresses
            return (queryResultCode QRSuccess)

getModuleListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getModuleListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getModuleList bhi) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getModuleSourceV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Module reference.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getModuleSourceV2 cptr blockType blockHashPtr moduleRefPtr outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    modRef <- decodeModuleRefInput moduleRefPtr
    res <- runMVR (Q.getModuleSource bhi modRef) mvr
    -- TODO: Consider splitting the module in chunks and streaming the results.
    returnMessage (copier outVec) outHash res

getInstanceListV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getInstanceListV2 cptr channel blockType blockHashPtr outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mInstances) <- runMVR (Q.getInstanceList bhi) mvr
    case mInstances of
        Nothing -> return (queryResultCode QRNotFound)
        Just instances -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) instances
            return (queryResultCode QRSuccess)

getInstanceInfoV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Smart contract instance index.
    Word64 ->
    -- |Smart contract instance subindex.
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getInstanceInfoV2 cptr blockType blockHashPtr addrIndex addrSubindex outHash outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    let caddr = ContractAddress (ContractIndex addrIndex) (ContractSubindex addrSubindex)
    res <- runMVR (Q.getInstanceInfo bhi caddr) mvr
    -- TODO: Consider whether we need to stream the model of v0 contracts.
    returnMessage (copier outVec) outHash res

getAncestorsV2 ::
    StablePtr Ext.ConsensusRunner ->
    Ptr SenderChannel ->
    -- |Block type.
    Word8 ->
    -- |Block hash.
    Ptr Word8 ->
    -- |Amount of ancestors (depth).
    Word64 ->
    -- |Out pointer for writing the block hash that was used.
    Ptr Word8 ->
    FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
    IO Int64
getAncestorsV2 cptr channel blockType blockHashPtr depth outHash cbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let sender = callChannelSendCallback cbk
    bhi <- decodeBlockHashInput blockType blockHashPtr
    (bh, mModules) <- runMVR (Q.getAncestors bhi (BlockHeight depth)) mvr
    case mModules of
        Nothing -> return (queryResultCode QRNotFound)
        Just modules -> do
            copyHashTo outHash bh
            _ <- enqueueMessages (sender channel) modules
            return (queryResultCode QRSuccess)

getTransactionStatusV2 ::
    StablePtr Ext.ConsensusRunner ->
    -- |Transaction hash.
    Ptr Word8 ->
    Ptr ReceiverVec ->
    -- |Callback to output data.
    FunPtr CopyToVecCallback ->
    IO Int64
getTransactionStatusV2 cptr trxHashPtr outVec copierCbk = do
    Ext.ConsensusRunner mvr <- deRefStablePtr cptr
    let copier = callCopyToVecCallback copierCbk
    trxHash <- decodeTransactionHashInput trxHashPtr
    res <- runMVR (Q.getTransactionStatus trxHash) mvr
    case res of
        Nothing -> do
          return $ queryResultCode QRNotFound
        Just ts -> case toTransactionStatus ts of
              Left _ -> return $ queryResultCode QRNotFound -- TODO: What to return here?
              Right t -> do
                let encoded = Proto.encodeMessage t
                BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier outVec (castPtr ptr) (fromIntegral len))
                return $ queryResultCode QRSuccess

{- |Write the hash to the provided pointer, and if the message is given encode and
   write it using the provided callback.
-}
returnMessage ::
    (Proto.Message (Output a), ToProto a) =>
    (Ptr Word8 -> Int64 -> IO ()) ->
    -- |Out pointer where the hash is written.
    Ptr Word8 ->
    -- |The hash of the block to which the message belongs, and potentially a
    -- message.
    (BlockHash, Maybe a) ->
    IO Int64
returnMessage _ outHash (bh, Nothing) = do
    copyHashTo outHash bh
    return (queryResultCode QRNotFound)
returnMessage copier outHash (bh, Just v) = do
    copyHashTo outHash bh
    let encoded = Proto.encodeMessage (toProto v)
    BS.unsafeUseAsCStringLen encoded (\(ptr, len) -> copier (castPtr ptr) (fromIntegral len))
    return (queryResultCode QRSuccess)

{- |Spawn a new thread that will invoke the provided callback on the list of
 encoded messages. If the callback response indicates that the channel to
 which the callback is enqueueing is full, the thread will wait. The wait time
 follows exponential backoff strategy to a maximum of 10 seconds.
-}
enqueueMessages :: (Proto.Message (Output a), ToProto a) => (Ptr Word8 -> Int64 -> IO Int32) -> [a] -> IO ThreadId
enqueueMessages callback = forkIO . go 0 . map encodeMsg
  where
    encodeMsg = Proto.encodeMessage . toProto
    go _ [] = () <$ callback nullPtr maxBound -- close the sender channel.
    go n msgs@(msg : msgs') =
        BS.unsafeUseAsCStringLen msg $ \(headPtr, len) -> do
            res <- callback (castPtr headPtr) (fromIntegral len)
            if res == 0
                then go 0 msgs' -- reset wait time to 10ms.
                else
                    if res == -1
                        then do
                            let delay = (2 ^ n) * 10_000
                            threadDelay delay
                            go (min (n + 1) (10 :: Int)) msgs -- maximum delay is 10 seconds
                        else return () -- the sender channel is now dropped, so we stop.

-- * Foreign exports

foreign export ccall
    getAccountInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Identifier type, 0 for account address, 1 for credential, 2 for account index
        Word8 ->
        -- |Serialized identifier. Length determined by the type.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getAccountListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getModuleSourceV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Module reference.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getInstanceListV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getAncestorsV2 ::
        StablePtr Ext.ConsensusRunner ->
        Ptr SenderChannel ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Amount of ancestors (depth).
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        FunPtr (Ptr SenderChannel -> Ptr Word8 -> Int64 -> IO Int32) ->
        IO Int64

foreign export ccall
    getInstanceInfoV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Block type.
        Word8 ->
        -- |Block hash.
        Ptr Word8 ->
        -- |Smart contract address index.
        Word64 ->
        -- |Smart contract address subindex.
        Word64 ->
        -- |Out pointer for writing the block hash that was used.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64

foreign export ccall
    getTransactionStatusV2 ::
        StablePtr Ext.ConsensusRunner ->
        -- |Transaction hash.
        Ptr Word8 ->
        Ptr ReceiverVec ->
        FunPtr (Ptr ReceiverVec -> Ptr Word8 -> Int64 -> IO ()) ->
        IO Int64
