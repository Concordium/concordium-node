module SimpleCounter where

import Prod
import Maybe
import Prim
import ListBase
import List
import Blockchain
import Helpers

data MsgCnt = Inc [Int64] | Dec [Int64]

def mkReturn :: Int64 -> Maybe.Maybe (Prod.Pair Int64 Prim.Transaction)
def mkReturn = Helpers.accept [Int64]

contract Counter where

  init (ia :: Int64) (c :: Prim.InitContext) (amount :: Amount) =
    ia

  receive (c :: Prim.ReceiveContext) (model :: Int64) (caller :: Blockchain.Caller) (amount :: Amount) (msg :: Maybe.Maybe MsgCnt) =
    case msg of
      Maybe.Nothing -> mkReturn model
      Maybe.Just (msg' :: MsgCnt) ->
        case msg' of
          Inc (n :: Int64) ->
            let initSeg :: ListBase.List Int64 = List.enumFromTo n in
            let sumList :: Int64 = List.sumList initSeg in
            let plus :: Int64 = Prim.plusInt64 model sumList in
            mkReturn plus
          Dec (n :: Int64) ->
            let initSeg :: ListBase.List Int64 = List.enumFromTo n in
            let sumList :: Int64 = List.sumList initSeg in
            let minus :: Int64 = Prim.minusInt64 model sumList in
            mkReturn minus
