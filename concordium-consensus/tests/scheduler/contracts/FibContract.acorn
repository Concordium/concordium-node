module FibContract where

import Prod
import Maybe
import Prim
import List
import Blockchain
import Unit
import Bool
import Ord
import Map
import IntMap
import Helpers

data MsgFib = Fib [Int64]

def mkReturn :: Map.Map Int64 Int64 -> Prim.Transaction -> Maybe.Maybe (Prod.Pair (Map.Map Int64 Int64) Prim.Transaction)
def mkReturn = Helpers.acceptMsgs [Map.Map Int64 Int64]

def reject :: Maybe.Maybe (Prod.Pair (Map.Map Int64 Int64) Prim.Transaction)
def reject = Helpers.reject [Map.Map Int64 Int64]

def insert :: Int64 -> Int64 -> Map.Map Int64 Int64 -> Map.Map Int64 Int64
def insert = IntMap.insert [Int64]

def baseValues :: Map.Map Int64 Int64
def baseValues =
   let emptyMap :: Map.Map Int64 Int64 = IntMap.empty [Int64] in
   let one :: Map.Map Int64 Int64 = insert 1 1 emptyMap in
   insert 0 1 one


def lookup :: Int64 -> Map.Map Int64 Int64 -> Maybe.Maybe Int64
def lookup = IntMap.lookup [Int64]

contract Fibonacci where

  init (ia :: Unit.Unit) (c :: Prim.InitContext) (amount :: Amount) =
    baseValues

  receive (c :: Prim.ReceiveContext) (model :: Map.Map Int64 Int64) (msg :: Maybe.Maybe MsgFib) =
    case msg of
      Maybe.Nothing -> mkReturn model Prim.TxNone
      Maybe.Just (msg' :: MsgFib) ->
          let amount :: Amount = Prim.receiveAmount c in
          case msg' of
              Fib (n :: Int64) ->
                let addr :: <address> = Prim.receiveSelfAddress c in
                let casted :: Maybe.Maybe Fibonacci = castFibonacci addr in
                case casted of
                  Maybe.Nothing -> reject
                  Maybe.Just (i :: Fibonacci) ->
                    let amodel :: Map.Map Int64 Int64 = getFibonacci i in
                    let lkp :: Maybe.Maybe Int64 = lookup n amodel in
                    case lkp of
                      Maybe.Just (_ :: Int64) -> mkReturn amodel Prim.TxNone -- if the value is already in the cache don't do anything
                      Maybe.Nothing ->
                        let cmp :: Ord.Ordering = Prim.compareInt64 n 2 in
                        case cmp of
                          Ord.LT -> mkReturn amodel Prim.TxNone
                          _ ->
                             let minusone :: Int64 = Prim.minusInt64 n 1 in
                             let checkminusone :: Maybe.Maybe Int64 = lookup minusone amodel in
                             case checkminusone of
                               Maybe.Nothing ->
                                 let msg1 :: MsgFib = Fib minusone in
                                 let msg2 :: MsgFib = Fib n in
                                 let tx1 :: Prim.Transaction = sendFibonacci i msg1 amount in
                                 let tx2 :: Prim.Transaction = sendFibonacci i msg2 amount in
                                 let tx :: Prim.Transaction = Prim.TxBatch tx1 tx2 in
                                 mkReturn amodel tx
                               Maybe.Just (v :: Int64) -> -- the value already exists, now check for n-2
                                 let minustwo :: Int64 = Prim.minusInt64 n 2 in
                                 let checkminustwo :: Maybe.Maybe Int64 = lookup minustwo amodel in
                                 case checkminustwo of
                                   Maybe.Nothing ->
                                     let msg1 :: MsgFib = Fib minusone in
                                     let msg2 :: MsgFib = Fib minustwo in
                                     let msg0 :: MsgFib = Fib n in
                                     let tx1 :: Prim.Transaction = sendFibonacci i msg2 amount in
                                     let tx2 :: Prim.Transaction = sendFibonacci i msg1 amount in
                                     let tx3 :: Prim.Transaction = sendFibonacci i msg0 amount in
                                     let tx4 :: Prim.Transaction = Prim.TxBatch tx2 tx3 in
                                     let tx :: Prim.Transaction = Prim.TxBatch tx1 tx4 in
                                     mkReturn amodel tx
                                   Maybe.Just (u :: Int64) ->
                                     let plus :: Int64 = Prim.plusInt64 u v in
                                     let newmodel :: Map.Map Int64 Int64 = insert n plus amodel in
                                     mkReturn newmodel Prim.TxNone
